# 4. 데이터베이스 메타데이터로 작업하기

SQLAlchemy Core와 ORM의 핵심은 SQL Expression 입니다.<br>
이 SQLAlchemy Core와 ORM은 파이썬 객체를 데이터베이스의 테이블과 컬럼처럼 사용할 수 있게 하기 위해서 만들어졌습니다.<br>
이러한 것들을 데이터베이스 메타데이터로 사용할 수 있습니다.

> 메타데이터는 데이터를 기술하는 데이터를 설명합니다. 기본적으로 SQLAlchemy 공식문서에서는 메타데이터라는 용어는 일반적으로 구성된 테이블, 열, 제약 조건 및 기타 객체 정보 등을 말합니다.

SQLAlchemy에서 가장 일반적으로 많이 사용하는 데이터베이스 메타데이터는 MetaData, Table, Column이 있습니다.
<br>
밑에서는 메타데이터를 어떻게 사용하는지 보여줍니다.
<br>
ORM 지향 스타일 뿐만 아니라 코어 지향 스타일도 적혀있습니다.

## 테이블 객체를 메타데이터 설정하기

관계형 데이터베이스로 작업할 때, 만들려는 기본구조를 쿼리를 통해서 테이블을 만듭니다.

SQLAlchemy에서는 테이블과 유사한 Python객체를 만듭니다.

SQLAlchemy 표현 언어를 시작할려면 사용할려는 데이터베이스 테이블을 Table 객체로 만들어줘야합니다.

각각 Table 객체를 코드를 통해서 명확하게 설정하거나, 기존으 데이터베이스의 정의되어 있는 것을 반영시킵니다.

이 두가지 접근법은 또한 여러가지 방법으로 혼합할 수 있습니다.

표를 선언하던 반영하던 우리는 컬렉션을 가지고 시작합니다. 우리가 메타데이터라고 하는 테이블을 배치할 것입니다.

이 물체는 본질적으로 파이썬 딕셔너리 형입니다. 키는 문자열에 일련의 테이블 개체를 저장합니다.

이런 개체를 구성하는 방법은 다음과 같습니다.

```python
>> from sqlalchemy import MetaData
>> metadata = MetaData()
```

메타 데이터 객체가 확보되면, 몇 가지의 테이블 객체를 선언할 수 있습니다.

user 테이블을 만들어 보겠습니다.

```python
from sqlalchemy import Table, Column, Integer, String
user_table = Table(
	'user_account',
	metadata,
	Column('id', Inteager, primaray_key=True),
	Column('id', String(30)),
	Column('fullname', String),
)
```

위 표 구조가 SQL CREATE TABLE문과 유사하게 느껴질 것이다. 테이블 이름부터 시작하여서 목록 표시 각 열을 정의했다.

위 코드를 나누어 보았다.

- Table : 데이터베이스 테이블을 나타내며 자체적으로 메타데이터 콜렉션을 할당합니다.
- Column : 데이터베이스 테이블의 열을 나타냅니다. 테이블 객체에 할당합니다. Column은 일반적으로 문자열 이름과 유형 개체가 포함됩니다.

```Python
>>> user_table.c.name
Column('name', String(length=30), table=<user_account>)

>>> user_table.c.keys()
['id', 'name', 'fullname']
```

- Integer, String : 클래스들은 SQL 데이터타입을 재현하며, 반드시 Column안에서 인스턴스화 되어야 합니다. 우리는 길이를 30으로 이름은 name 클래스로 지정할 경우 인스턴스 String(30)으로 선언해줘야합니다. 그러나 id와 fullname을 지정하지 않으므로 클래스 자체를 보낼 수 있습니다.

## 단순제약조건

우리는 위의 user 테이블을 통해서 이미 Column.primary_key 파라미터를 보았습니다. 이는 기본키를 선언했습니다.

기본키는 암시적으로 PrimaryKeyConstraint 구조로 선언되어있습니다. 이는 다음의 명령어로 확인할 수 있습니다.

```python
>>> user_table.primary_key
PrimaryKeyConstraint(Column('id', Integer(), table=<user_account>, primary_key=True, nullable=False))
```

일반적으로 명시적으로 선언되는 제약조건은 데이터베이스에 해당하는 ForeignKeyConstraint 객체 외래 키 제약 조건을 달 수 있습니다.

테이블을 선언할 때도 외부키를 사용할 수 있습니다. CREATE문 내에서 다음을 수행할 수 있도록 하기 위한 것 뿐만 아니라 데이터베이스뿐만 아니라 SQL 표현식 구성에도 도움이 됩니다.

단일 열만 포함하는 외부 키 제약 조건 대상 테이블을 일반적으로 열 수준 약어 표기법을 사용하여 선언됩니다. ForegignKey 객체를 통해 아래에 두 번째 표를 선언합니다. 참조하는 외부키 제약 조건이 있는 주소 테이블입니다.

```python
>>> from sqlalchemy import ForeignKey
>>> address_table = Table(
...     "address",
...     metadata,
...     Column('id', Integer, primary_key=True),
...     Column('user_id', ForeignKey('user_account.id'), nullable=False),
...     Column('email_address', String, nullable=False)
... )
```

이 테이블은 세번째 조약 조건도 나와 있습니다.

SQL에서 이 제약 조건은 위에 Column.nullable을 사용하여 표시된 "NOT NULL"제약 조건입니다.

> ForeignKey 객체를 사용하기 위해서 Column 선언을 할 때, 우리는 데이터타입을 생략할 수 있습니다. 이건 자동으로 추론하여서 관계된 값을 찾아서 타입을 지정해줍니다.

다음 섹션에서는 완료된 DDL을 사용자에게 전송하고 주소표에서 전송하고 주소 표에서 완료된 결과를 확인합니다.

## 데이터베이스 DDL 전송

우리는 코드를 통해서 데이터베이스 테이블을 객체로 정교하게 선언했고, 이는 MetaData 객체를 기반으로 Table 객체를 만들었다.

그리고 Table 객체는 Column과 Constraint 객체를 합쳐서 만들었습니다.

우리는 이렇게 선언한 객체들을 데이터베이스에 쿼리로 보내주어야 합니다.

이런 객체로 된 코드를 데이터베이스 쿼리로 바꿔주어서 만드는 메소드는 다음과 같다.

```python
>>> metadata.create_all(engine)

BEGIN (implicit)
PRAGMA main.table_...info("user_account")
...
PRAGMA main.table_...info("address")
...
CREATE TABLE user_account (
    id INTEGER NOT NULL,
    name VARCHAR(30),
    fullname VARCHAR,
    PRIMARY KEY (id)
)
...
CREATE TABLE address (
    id INTEGER NOT NULL,
    user_id INTEGER NOT NULL,
    email_address VARCHAR NOT NULL,
    PRIMARY KEY (id),
    FOREIGN KEY(user_id) REFERENCES user_account (id)
)
...
COMMIT
```

기본적으로 DDL 생성 프로세스에는 일부 SQLite 관련 PRAGMA 문이 포함됩니다. CREATE를 방출하기 전에 각 테이블의 존재 여부를 테스트합니다.

전체 단계의 BEGIN, COMMIT에도 일련의 단계가 포함되어 수용 가능 트랜잭션 DDL로 실행했습니다.

## ORM을 사용하는 테이블 메타데이터 정의

위의 데이터베이스 구조를 만들고 제약조건을 똑같이 사용하지만 ORM 중심으로 코드를 짜서 사용할 수 있습니다.

### 레지스트리 설정

ORM을 사용할때, MetaData 콜렌션을 그대로 유지됩니다. 그러나 이 자체로는 알려진 ORM 전용 개체 내에 포함되어 있습니다.

```python
>>> from sqlalchemy.orm import registry
>>> mapper_registry = registry()
```

위 registery가 구성되면, 자도응로 MetaData 객체를 포함합니다.

```python
>>> mapper_registry.metadata
MetaData()
```

이제 테이블 객체를 직접 선언하는 대신 간접적으로 선언합니다.

매핑된 각 클래스가 공통 기본 클래스에서 내려오는 가장 일반적인 접근 방식 선언적 근거리로 알려져있습니다.

```python
>>> Base = mapper_registry.generate_base()
```

레지스트리 및 declarative base(선언자료)를 생성하는 방법에 이런 방법도 있습니다.

```python
from sqlalchemy.orm import declarative_base
Base = declarative_base()
```

### 매핑된 클래스 선언

Base 객체는 파이썬 클래스로 기본 클래스 역학을 합니다. ORM 매핑된 클래스에 대해 선언합니다.

이제 ORM 매핑된 클래스를 정의할 수 있습니다.

```python
>>> from sqlalchemy.orm import relationship
>>> class User(Base):
...     __tablename__ = 'user_account'
...
...     id = Column(Integer, primary_key=True)
...     name = Column(String(30))
...     fullname = Column(String)
...
...     addresses = relationship("Address", back_populates="user")
...
...     def __repr__(self):
...        return f"User(id={self.id!r}, name={self.name!r}, fullname={self.fullname!r})"

>>> class Address(Base):
...     __tablename__ = 'address'
...
...     id = Column(Integer, primary_key=True)
...     email_address = Column(String, nullable=False)
...     user_id = Column(Integer, ForeignKey('user_account.id'))
...
...     user = relationship("User", back_populates="addresses")
...
...     def __repr__(self):
...         return f"Address(id={self.id!r}, email_address={self.email_address!r})"
```

위 코드는 두 개의 클래스를 만들어서 ORM을 만들었고, 쿼리 기능을 사용할 수 있습니다.

위 처럼 지정하면 Table 객체도 포함되어 있습니다.

그들은 일부로 생성된 테이블 객체가 포함되어 있습니다. 이는 다음의 코드를 통해서 확인할 수 있습니다.

```python
>>> User.__table__
Table('user_account', MetaData(),
    Column('id', Integer(), table=<user_account>, primary_key=True, nullable=False),
    Column('name', String(length=30), table=<user_account>),
    Column('fullname', String(), table=<user_account>), schema=None)
```

이 Table 객체는 선언적 프로세스에서 생성되었습니다. 각 클래스에 정의된 **tablename** 속성을 기반으로 합니다.

### 기타 매핑 클래스 관련 정보

위 강의에 대한 몇 가지 빠른 설명은 다음을 참고하세요.

- 클래스는 자동으로 `__init__()` 메서드를 생성합니다.

```python
>>> sandy = User(name="sandy", fullname="Sandy Cheeks")
```

- `__repr__()` 메서드를 사용하기 : 이건 선택 사항이다. 그리고 엄격히 말해서 우리 맞춤식 클래스가 설명 문자열 표현을 가질 수 있도록 달리 필요하지 않다.

```python
>>> sandy
User(id=None, name='sandy', fullname='Sandy Cheeks')
```

- 양방향 관계 포함 : 선택 사항 입니다. 여기서 ORM을 사용하여서 사용자와 주소 클래스에서 서로를 참조하게 만들었습니다.

### 데이터베이스에 DDL을 내보내기

이 내용은 데이터베이스에 DDL 내보내기 내용과 동일합니다.

이는 DDL을 방출할 때 ORM 매핑된 클래스와 다르지 않습니다.

DDL을 방출할려는 경우의 일부로 생성한 테이블 객체의 경우 확실히 지도화된 우리의 수업들은 우리는 여전히 사용할 수 있습니다.

```python
# emit CREATE statements given ORM registry
mapper_registry.metadata.create_all(engine)

# the identical MetaData object is also present on the
# declarative base
Base.metadata.create_all(engine)
```

### 핵심 테이블 선언과 ORM 선언의 결합

두 가지 방식을 섞어서 다음과 같이 사용이 가능합니다. 이의 형태를 하이브리드 테이블이라고 합니다.

```python
class User(Base):
    __table__ = user_table

     addresses = relationship("Address", back_populates="user")

     def __repr__(self):
        return f"User({self.name!r}, {self.fullname!r})"

class Address(Base):
    __table__ = address_table

     user = relationship("User", back_populates="addresses")

     def __repr__(self):
         return f"Address({self.email_address!r})"
```
