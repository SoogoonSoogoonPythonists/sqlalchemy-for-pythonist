# 4. 데이터베이스 메타데이터로 작업하기

SQLAlchemy Core와 ORM의 핵심은 SQL Expression 입니다.<br>
이 SQLAlchemy Core와 ORM은 파이썬 객체를 데이터베이스의 테이블과 컬럼처럼 사용할 수 있게 하기 위해서 만들어졌습니다.<br>
이러한 것들을 데이터베이스 메타데이터로 사용할 수 있습니다.

> 메타데이터는 데이터를 기술하는 데이터를 설명합니다. 기본적으로 SQLAlchemy 공식문서에서는 메타데이터라는 용어는 일반적으로 구성된 테이블, 열, 제약 조건 및 기타 객체 정보 등을 말합니다.

SQLAlchemy에서 가장 일반적으로 많이 사용하는 데이터베이스 메타데이터는 MetaData, Table, Column이 있습니다.
<br>
ORM 지향 스타일 뿐만 아니라 코어 지향 스타일도 있습니다.

## 테이블 객체를 메타데이터 설정하기

관계형 데이터베이스로 작업할 때, 만들려는 기본구조를 쿼리를 통해서 테이블을 만듭니다.

SQLAlchemy에서는 데이터베이스 테이블과 유사한 Python객체를 만듭니다.

SQLAlchemy 표현 언어를 시작할려면 사용할려는 데이터베이스 테이블을 Table 객체로 만들어줘야합니다.

각각 Table 객체를 코드를 통해서 명확하게 설정하거나, 기존으 데이터베이스에 정의되어 있는 것을 반영합니다.

우리가 메타데이터라고 하는 테이블을 배치할 것입니다.

메타데이터 객체는 본질적으로 파이썬 딕셔너리 형입니다. 키는 문자열에 일련의 테이블 개체를 저장합니다.

코드는 다음과 같습니다.

```python
>> from sqlalchemy import MetaData
>> metadata = MetaData()
```

메타 데이터 객체가 확보되면, 몇 가지의 테이블 객체를 선언할 수 있습니다.

user 테이블을 코드를 통해서 만들어보겠습니다.

```python
from sqlalchemy import Table, Column, Integer, String
user_table = Table(
	'user_account',
	metadata,
	Column('id', Inteager, primaray_key=True),
	Column('id', String(30)),
	Column('fullname', String),
)
```

위 표 구조가 SQL CREATE TABLE문과 유사합니다.

테이블 이름부터 시작해서 각 열을 정의하였습니다.

위 코드를 나누어 보았다.

- Table : 데이터베이스 테이블을 나타내며 자체적으로 MetaData Collection을 할당합니다.
- Column : 데이터베이스 테이블의 열을 나타내며, 테이블 객체에 할당합니다. Column은 일반적으로 문자열 이름과 유형 객체가 포함됩니다.

```Python
>>> user_table.c.name
Column('name', String(length=30), table=<user_account>)

>>> user_table.c.keys()
['id', 'name', 'fullname']
```

- Integer, String : 클래스들은 SQL 데이터타입을 재현하며, 반드시 Column안에서 인스턴스화 되어야 합니다. 예를들어서 길이를 30으로 이름은 name 클래스로 지정할 경우 인스턴스 String(30)으로 선언합니다.

## 단순제약조건

우리는 위의 user 테이블을 통해서 이미 Column.primary_key 파라미터 값을 보았습니다. 이는 기본키를 선언해줍니다.

기본키는 암시적으로 PrimaryKeyConstraint 객체에 구조로 선언되어있습니다. 이는 다음의 명령어로 확인할 수 있습니다.

```python
>>> user_table.primary_key
PrimaryKeyConstraint(Column('id', Integer(), table=<user_account>, primary_key=True, nullable=False))
```

대부분의 제약조건은 데이터베이스에 해당하는 ForeignKeyConstraint 객체 외래 키 제약 조건을 달 수 있습니다.

테이블을 선언할 때도 외부키를 사용할 수 있습니다. CREATE문 내에서 다음을 수행할 수 있도록 하기 위한 것 뿐만 아니라 데이터베이스뿐만 아니라 SQL 표현식 구성에도 도움이 됩니다.

단일 열만 포함하는 외부 키 제약 조건 대상 테이블을 일반적으로 열 수준 약어 표기법을 사용하여 선언됩니다. ForegignKey 객체를 통해 아래와 같은 방법으로 선언할 수 있습니다.

```python
>>> from sqlalchemy import ForeignKey
>>> address_table = Table(
...     "address",
...     metadata,
...     Column('id', Integer, primary_key=True),
...     Column('user_id', ForeignKey('user_account.id'), nullable=False),
...     Column('email_address', String, nullable=False)
... )
```

이 테이블은 세번째 조약 조건도 나와 있습니다.

SQL에서 이 제약 조건은 위에 Column.nullable을 사용하여 표시된 "NOT NULL"제약 조건입니다.

> ForeignKey 객체를 사용하기 위해서 Column 선언을 할 때, 데이터타입을 생략할 수 있습니다. 이는 자동으로 추론하여서 관계된 값을 찾아서 타입을 지정해줍니다.

## 데이터베이스 DDL 전송

지금까지 코드를 통해서 데이터베이스 테이블을 객체로 가져왔고, 이는 MetaData 객체를 기반으로 Table 객체로 만들었습니다.

지금까지 선언한 객체들을 데이터베이스에 쿼리로 보내주어야 합니다.

이런 객체로 된 코드를 데이터베이스 쿼리로 바꿔주어서 만드는 메소드인 MetaData.create_all()을 사용하시면 됩니다.

```python
>>> metadata.create_all(engine)

BEGIN (implicit)
PRAGMA main.table_...info("user_account")
...
PRAGMA main.table_...info("address")
...
CREATE TABLE user_account (
    id INTEGER NOT NULL,
    name VARCHAR(30),
    fullname VARCHAR,
    PRIMARY KEY (id)
)
...
CREATE TABLE address (
    id INTEGER NOT NULL,
    user_id INTEGER NOT NULL,
    email_address VARCHAR NOT NULL,
    PRIMARY KEY (id),
    FOREIGN KEY(user_id) REFERENCES user_account (id)
)
...
COMMIT
```

위와 같은 DDL 코드로 바뀌게 됩니다.

## ORM 지향 방식으로 테이블 메타데이터 정의

위의 데이터베이스 구조를 만들고 제약조건을 똑같이 사용하지만 ORM 중심의 방식으로 코드를 작성할 수 있습니다.

### 레지스트리 설정

ORM을 사용할때, MetaData을 그대로 유지됩니다.

ORM을 사용하기 위해서 registry 객체를 포함해야합니다.

```python
>>> from sqlalchemy.orm import registry
>>> mapper_registry = registry()
```

위 registery 객체를 구성되면, 자동으로 MetaData 객체를 포함합니다.

```python
>>> mapper_registry.metadata
MetaData()
```

이제 테이블 객체를 직접 선언하는 대신 간접적으로 선언합니다.

매핑된 각 클래스가 공통 기본 클래스에서 내려오는 가장 일반적인 접근 방식 선언적 근거리로 알려져있습니다.

```python
>>> Base = mapper_registry.generate_base()
```

#### Tip

한 번의 코드를 통해서 registry 선언과 "declarative base"(선언 자료) 클래스를 사용할 수 있는 다음과 같은 방법이 있습니다.

```python
from sqlalchemy.orm import declarative_base
Base = declarative_base()
```

### 매핑할 클래스 선언

Base 객체는 파이썬 클래스로 기본 클래스 역할을 수행합니다. 이 방법을 통해서 ORM을 매핑하며 데이터베이스의 테이블을 선언할 수 있습니다.

```python
>>> from sqlalchemy.orm import relationship
>>> class User(Base):
...     __tablename__ = 'user_account'
...
...     id = Column(Integer, primary_key=True)
...     name = Column(String(30))
...     fullname = Column(String)
...
...     addresses = relationship("Address", back_populates="user")
...
...     def __repr__(self):
...        return f"User(id={self.id!r}, name={self.name!r}, fullname={self.fullname!r})"

>>> class Address(Base):
...     __tablename__ = 'address'
...
...     id = Column(Integer, primary_key=True)
...     email_address = Column(String, nullable=False)
...     user_id = Column(Integer, ForeignKey('user_account.id'))
...
...     user = relationship("User", back_populates="addresses")
...
...     def __repr__(self):
...         return f"Address(id={self.id!r}, email_address={self.email_address!r})"
```

위 코드는 두 개의 클래스를 만들어서 ORM을 만들었고, 쿼리 기능을 사용할 수 있습니다.

위 코드는 Table 객체가 포함되어 있습니다. 이는 다음의 코드를 통해서 확인할 수 있습니다.

```python
>>> User.__table__
Table('user_account', MetaData(),
    Column('id', Integer(), table=<user_account>, primary_key=True, nullable=False),
    Column('name', String(length=30), table=<user_account>),
    Column('fullname', String(), table=<user_account>), schema=None)
```

이 Table 객체는 선언적 프로세스에서 생성되었습니다. 각 클래스에 정의된 `__tablename__` 속성을 기반으로 이름을 정합니다.

### 기타 매핑 클래스 관련 정보

위 코드에 대한 특징 설명입니다.

- 클래스는 자동으로 `__init__()` 메서드를 생성됩니다. 이를 통해서 인스턴스 생성을 편하게 할 수 있습니다.

```python
>>> sandy = User(name="sandy", fullname="Sandy Cheeks")
```

- `__repr__()` 메서드를 사용하기 : (선택 사항) 이를 통해서 클래스의 출력 양식을 제공해줄 수 있습니다.

```python
>>> sandy
User(id=None, name='sandy', fullname='Sandy Cheeks')
```

- 양방향 관계 포함 : (선택 사항) ORM의 구조안에 relationship()를 사용하여, 사용자와 주소 클래스에서 서로를 참조하게 만들었습니다.

### 데이터베이스에 DDL을 내보내기

이 내용은 데이터베이스에 DDL 내보내기 내용과 동일합니다.

이는 DDL을 방출할 때 ORM 매핑된 클래스와 다르지 않습니다.

아래의 코드를 참고하시면 됩니다.

```python
# emit CREATE statements given ORM registry
mapper_registry.metadata.create_all(engine)

# the identical MetaData object is also present on the
# declarative base
Base.metadata.create_all(engine)
```

## 코어 지향 방식과 ORM 지향 방식을 결합하여 사용하기

우리는 핵심적으로 Table 클래스를 만들어서 생성하는 코어 지향 방식과 Base를 상속시켜서 클래스로 만드는 ORM 지향 방식 두 가지 방식을 사용했습니다.

두 가지 방식을 섞어서 다음과 같이 사용이 가능합니다. 이의 형태를 하이브리드 테이블이라고 합니다.

```python
class User(Base):
    __table__ = user_table

     addresses = relationship("Address", back_populates="user")

     def __repr__(self):
        return f"User({self.name!r}, {self.fullname!r})"

class Address(Base):
    __table__ = address_table

     user = relationship("User", back_populates="addresses")

     def __repr__(self):
         return f"Address({self.email_address!r})"
```

## 테이블 역생성

우리는 MetaData 객체를 사용하거나 이를 포함하는 객체를 사용하여서 테이블을 선언하였습니다. 그리고 MetaData에 Table을 포함하여서 코드를 작성했습니다. 그러나 이와 다르게 Table 객체에 MetaData를 선언하여서 사용할 수 있습니다.

```python
>>> some_table = Table("some_table", metadata, autoload_with=engine)

BEGIN (implicit)
PRAGMA main.table_...info("some_table")
[raw sql] ()
SELECT sql FROM  (SELECT * FROM sqlite_master UNION ALL   SELECT * FROM sqlite_temp_master) WHERE name = ? AND type = 'table'
[raw sql] ('some_table',)
PRAGMA main.foreign_key_list("some_table")
...
PRAGMA main.index_list("some_table")
...
ROLLBACK
```

다음과 같은 테이블을 생성하게 됩니다.

```python
>>> some_table
Table('some_table', MetaData(),
    Column('x', INTEGER(), table=<some_table>),
    Column('y', INTEGER(), table=<some_table>),
    schema=None)
```
