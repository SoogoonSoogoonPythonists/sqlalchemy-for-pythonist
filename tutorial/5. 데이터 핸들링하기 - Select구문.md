# 5. 데이터 핸들링 - Core, ORM으로 행 조회하기

<br>

이번 섹션에서는 SQLAlchemy에서 가장 자주 쓰이는 Select에 대해서 다룹니다.

<br>

## `select()` 를 통한 SQL 표현식 구성
select() 생성자는 insert() 생성자와 같은 방식으로 쿼리문을 만들 수 있습니다.

```python
>>> from sqlalchemy import select
>>> stmt = select(user_table).where(user_table.c.name == 'spongebob')
>>> print(stmt)
"""
SELECT user_account.id, user_account.name, user_account.fullname
FROM user_account
WHERE user_account.name = :name_1
"""
```

마찬가지로 쿼리문을 실행시키 위해 같은 레벨의 SQL 생성자들(select, insert, update, create등)처럼 execution 메서드에 쿼리를 넣어 실행시킬 수 있습니다.

```python
>>> with engine.connect() as conn:
...     for row in conn.execute(stmt):
...         print(row)
(1, 'spongebob', 'Spongebob Squarepants')
```

한편 ORM을 사용해 `select` 쿼리문을 실행시키고 싶을 때는 `Session.exeucte()`를 사용해야합니다. 
결과는 방금 전의 예제와 마찬가지로 `Row`객체를 반환하지만 이 객체는 이전의 튜토리얼, [4. 데이터베이스 메타데이터로 작업하기](https://github.com/SoogoonSoogoonPythonists/sqlalchemy-for-pythonist/blob/main/tutorial/4.%20%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4%20%EB%A9%94%ED%83%80%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%A1%9C%20%EC%9E%91%EC%97%85%ED%95%98%EA%B8%B0.md#%ED%85%8C%EC%9D%B4%EB%B8%94%EC%97%90-%EB%A7%A4%ED%95%91%ED%95%A0-%ED%81%B4%EB%9E%98%EC%8A%A4-%EC%84%A0%EC%96%B8)에서 
정의했던 `User`객체를 포함하고 있습니다.

```python
>>> stmt = select(User).where(User.name == 'spongebob')
# User 클래스의 인스턴스 안에 있는 각 row 들을 출력
>>> with Session(engine) as session:
...     for row in session.execute(stmt):
...         print(row)
(User(id=1, name='spongebob', fullname='Spongebob Squarepants'),)
```

<br>

## FROM절과 컬럼 세팅하기

`select()`함수는 위치인자로 `Column`이나 ` Table`등을 포함한 다양한 객체들을 받을 수 있습니다.
이러한 인자 값들은 `select()`함수의 반환 값, 즉 SQL쿼리문으로 표현 될 수있고 `FROM`절을 세팅해주기도 합니다.


```python
>>> print(select(user_table))
“””
SELECT user_account.id, user_account.name, user_account.fullname
FROM user_account
“””
```

각 각의 컬럼들을 `Core`를 이용해 조회하려면 `Table.c`접근자를 통해 `Column`객체에 접근하면 됩니다.

```python
>>> print(select(user_table.c.name, user_table.c.fullname))
“””
SELECT user_account.name, user_account.fullname
FROM user_account
“””
```

<br>


### ORM 엔터티 및 열 조회

SQL 쿼리를  SqlAlchemy에서 구현할 때 테이블이나 컬럼을 표현하기 위해 `User`클래스같은 ORM 엔터티나, `User.name`과 같이  컬럼이 매핑된 속성(어트리뷰트)을 사용할 수 있습니다.
아래의 예제는  `User`엔터티를 조회하는 예제이지만 사실은
`user_table` 를 사용했을 때와 결과가 동일합니다.

```python
>>> print(select(User))
“””
SELECT user_account.id, user_account.name, user_account.fullname
FROM user_account
“””
```

위의 예제의 쿼리를 ORM `Session.exeucte()`를 통해 똑같이 실행 할 수 있는데, 이때는  `User`엔터티를 조회하는 것과 `user_info`를 조회하는 것에 차이가 있습니다.
`user_info`를 조회하든 `User`엔티티를  조회 하든 둘 다`Row`객체가 반환되지만 ` User`엔터티를 조회 할 경우에는
`User`인스턴스를 포함한 `Row` 객체가 반환됩니다.

> 여기서 `user_table`과 `User`는 [이전 장]()에서 만들어졌는데,
>  `user_table`은 `Table` 객체이고 
> `User`는  `Base` 클래스를  상속받아`Table`객체를 포함하고 있는 엔터티입니다.

```python
>>> with Session(engine) as session:
...     row = session.execute(select(User)).first()
...     print(row)

(User(id=1, name='spongebob',fullname='Spongebob Squarepants'),)
```

한편 클래스 바운드 속성(class-bound attributes)을 사용해 원하는 컬럼들을 조회할 수도 있습니다. 
```python
>>> print(select(User.name, User.fullname))
“””
SELECT user_account.name, user_account.fullname
FROM user_account
“”’
```

클래스 바운드 속성을 `Session.execute()`을 이용해 조회 할 경우에는 
인자로 보내진 클래스 바운드 속성의 값(컬럼 값)이 아래와 같이 반환됩니다.
```python
>>> with Session(engine) as session:
…	row = session.execute(select(User.name, User.fullname)).first()
…	print(row)

('spongebob', 'Spongebob Squarepants')
```

이러한 방법들은 믹스인 방법으로 섞어서 사용할 수도 있습니다.
```python
>>> session.execute(
...     select(User.name, Address).
...     where(User.id==Address.user_id).
...     order_by(Address.id)
... ).all()

[('spongebob', Address(id=1, email_address='spongebob@sqlalchemy.org')),
('sandy', Address(id=2, email_address='sandy@sqlalchemy.org')),
('sandy', Address(id=3, email_address='sandy@squirrelpower.org'))]
```

<br>

### 라벨링된 SQL 표현식 조회하기

`select name as username from user_account`쿼리를 실행 할 경우 아래와 같은 결과가 나옵니다.

|username|
|------|
|patrick|
|sandy|
|spongebob|

여기서 우리는 `name`컬럼의 이름을 `username`으로 라벨링 해줬기 때문에 상단 컬럼에 `username` 이 뜨는 건데요.
이러한 기능을 SQLAlchemy의 `ColumnElement.label() `함수를 이용해 동일하게 구현할 수 있습니다.
```python
>>> from sqlalchemy import func, cast
>>> stmt = (
...     select(
...         ("Username: " + user_table.c.name).label("username"),
...     ).order_by(user_table.c.name)
... )
>>> with engine.connect() as conn:
...     for row in conn.execute(stmt):
...         print(f"{row.username}")

Username: patrick
Username: sandy
Username: spongebob
```
<br>

### 문자열 컬럼 조회하기

보통 `Select`객체나 `select()` 생성자를 이용 해 컬럼을 조회하는 경우가 많지만 가끔은 임의로 문자열과 함께 컬럼을 조회 해야하는 경우가 있습니다.   이번 섹션에서는 이러한 스트링 데이터를 조회 하는 방법에 다룹니다.  

text() 생성자는 이전 장 [3. 트랜잭션 및 DBAPI 작업](https://github.com/SoogoonSoogoonPythonists/sqlalchemy-for-pythonist/blob/main/tutorial/3.%20%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98%20%EB%B0%8F%20DBAPI%20%EC%9E%91%EC%97%85.md)에서 한 번 소개가 되었는데요, 이 text()생성자안에  `SELECT`구문을 곧바로 넣어 사용할 수도 있었습니다.


한편 우리는  `select  ‘some_phrase’, name from user_account`와 같은 쿼리를 실행시키고 싶다고 생각해봅시다.
이때  `some_phrase`은 문자열이기 때문에  꼭 큰따옴표나 작은 따옴표로 감싸줘야합니다  
.그리고 그결과 출력물에도 어쩔 수 없이 작은 따옴표가 전부 붙어서 나옵니다.  

```python
>>> from sqlalchemy import text
>>> stmt = (
...     select(
...         text("'some phrase'"), user_table.c.name
...     ).order_by(user_table.c.name)
... )
>>> with engine.connect() as conn:
...     print(conn.execute(stmt).all())
[('some phrase', 'patrick'), ('some phrase', 'sandy'), ('some phrase', 'spongebob')]
```
그래서 보통은 `text()`보다 `literal_column()`을 사용해 작은 따옴표가 결과물에 붙어져서 나오는 문제를 해결할 수 있습니다.  
여기에서  `text`와 `literal_column()`은 거의 비슷하지만  `literal_column()`은 명시적으로 컬럼을 의미하고, 서브쿼리나 다른 SQL 표현식에서 쓰일 수 있게 라벨링도 할 수 있습니다.  

```python
>>> from sqlalchemy import literal_column
>>> stmt = (
...     select(
...         literal_column("'some phrase'").label("p"), user_table.c.name
...     ).order_by(user_table.c.name)
... )
>>> with engine.connect() as conn:
...     for row in conn.execute(stmt):
...         print(f"{row.p}, {row.name}")
some phrase, patrick
some phrase, sandy
some phrase, spongebob

```

<br>

## WHERE절

SQLAlchemy를 사용하면 Python 연산자를 사용하여 `name` = 'thead' 또는 `user_id` > 10인 데이터만 출력하는 쿼리를 쉽게 작성할 수 있습니다.

```python
>>> print(user_table.c.name == 'squidward')
user_account.name = :name_1

>>> print(address_table.c.user_id > 10)
address.user_id > :user_id_1
```

`WHERE`절을 만들기 위해 `Select.where()`메서드안에 인자값을 넣어 사용할 수도 있습니다.

```python
>>> print(select(user_table).where(user_table.c.name == 'squidward'))
"""
SELECT user_account.id, user_account.name, user_account.fullname
FROM user_account
WHERE user_account.name = :name_1
"""
```


where 절을 통한 join을 구현 할 경우 아래와 같이 작성 가능합니다.
```python
>>> select(address_table.c.email_address)
...     where(user_table.c.name == 'squidward').
...     where(address_table.c.user_id == user_table.c.id)
... 


>>> # 위와 같은 표현
...     select(address_table.c.email_address).
...     where(
...          user_table.c.name == 'squidward',
...          address_table.c.user_id == user_table.c.id
...     )
...
```

and_(), or_()등의 연결 구문도 구현가능합니다.

```python
>>> from sqlalchemy import and_, or_
>>>     select(Address.email_address).
...     where(
...         and_(
...             or_(User.name == 'squidward', User.name == 'sandy'),
...             Address.user_id == User.id
...         )
...     )
... 
```

단순히 같은지, 아닌지 비교하는 경우(equality) `Select.filter_by()`도 자주 사용됩니다.
```python
>>>select(User).filter_by(name='spongebob', fullname='Spongebob Squarepants')
```

<br>

## FROM절과 JOIN 명시하기

앞에서 언급했지만 `FROM`절은 따로 명시하지 않아도 `select()`를 이용해 조회하고 싶은 컬럼을넣는 것 만으로도
세팅을 할 수 있었습니다.
```python
>>> print(select(user_table.c.name))
“””
SELECT user_account.name
FROM user_account
“””
```

만약 ` select()`의 위치 인자로  서로 다른 두 개의 테이블을  참조하는 컬럼을`,`(컴마)로 구분지어 넣을 수도 있습니다
```python
>>> print(select(user_table.c.name, address_table.c.email_address))
“””
SELECT user_account.name, address.email_address
FROM user_account, address
“””
```

서로 다른 두 개의 테이블을 `JOIN`조인하고 싶다면, 이용할 수 있는 메서드가 두 가지가 있는데요,
하나는 `Select.join()`메서드로 명시적으로 `JOIN` 할 왼쪽에 들어갈 테이블, 오른 쪽에 들어 갈 테이블을 직접 지정할 수 있습니다
```python
>>> print(
...     select(user_table.c.name, address_table.c.email_address).
...     join_from(user_table, address_table)
... )
“””
SELECT user_account.name, address.email_address
FROM user_account JOIN address ON user_account.id = address.user_id
“””
```

다른 하나는 `select.join()`메서드로 오른쪽에 들어갈 테이블만 명시적으로 적어주고 
나머지 테이블은 암시적으로 컬럼을 선택할 때 참조하게 합니다.
```python
side is inferred:
>>> print(
...     select(user_table.c.name, address_table.c.email_address).
...     join(address_table)
... )
“””
SELECT user_account.name, address.email_address
FROM user_account JOIN address ON user_account.id = address.user_id
“””
```
또는 `JOIN` 하는 두 개의 테이블을 조금 더 명시적으로 작성하고 싶거나 `FROM`절에 명시적인 추가 옵션을 주고 싶다면
 아래와 같이 작성 할 수도 있습니다.
```python
>>> print(
...     select(address_table.c.email_address).
...     select_from(user_table).join(address_table)
... )
"""
SELECT address.email_address
FROM user_account JOIN address ON user_account.id = address.user_id
"""
```

`Select.select_from()`을 사용하는 또 다른 경우는 우리가 조회하고 싶은 컬럼들을 통해 암시적으로 FROM절을 세팅할 수 없는 경우입니다.   예를 들면 일반적인 SQL 쿼리문에서 `count(*)`를 조회하기 위해선  SQLAlchemy의 `sqlalchemy.sql.expression.func`를 사용해야합니다.


```python
>>> from sqlalchemy import func
>>> print(select(func.count('*')).select_from(user_table))
"""
SELECT count(:count_2) AS count_1
FROM user_account
"""
```

<br>

### On절 세팅하기

그런데 뭔가 이상한게 있었죠? 
사실 이 전의 예제에서 `Select.select_from()`이나 ` select.join()`을 이용해 두 테이블을 `JOIN`할 때 암시적으로 `ON절`이 세팅되었답니다.    
왜 자동으로  `ON` 절이 세팅 됐냐면, `user_table`객체와, `address_table` 객체가 ` ForeignKeyConstraint`, 즉 외부키 제약을 갖고 있어서 자동으로 세팅이 된 것입니다.  

만약에 `Join`의 대상인 두 개의 테이블에서 이러한 제약 key가 없을 경우 `ON` 절을 직접 지정해야 합니다. 이러한 기능은 `Select.join()`과 `Select.join_from()`메서드 둘 다 명시적으로 `ON`절을 세팅할 수 있습니다.

```python
>>> print(
...     select(address_table.c.email_address).
...     select_from(user_table).
...     join(address_table, user_table.c.id == address_table.c.user_id)
... )
"""
SELECT address.email_address
FROM user_account JOIN address ON user_account.id = address.user_id
"""
```
<br>


### OUTER, FULL Join

SQLAlchemy에서 `LEFT OUTER JOIN`, `FULL OUTER JOIN`를 구현하려면
`Select.join()`과 `Select.join_from()`메서드의 키워드 인자로 `Select.join.isouter`,
`Select.join.full `를 사용할 수 있습니다.


`LEFT OUTER JOIN`을 구현 한 경우, 
```python
>>> print(
...     select(user_table).join(address_table, isouter=True)
... )
"""
SELECT user_account.id, user_account.name, user_account.fullname
FROM user_account LEFT OUTER JOIN address ON user_account.id = address.user_id
"""
```
`FULL OUTER JOIN`을 구현 한 경우,
```python
>>> print(
...     select(user_table).join(address_table, full=True)
... )
"""
SELECT user_account.id, user_account.name, user_account.fullname
FROM user_account FULL OUTER JOIN address ON user_account.id = address.user_id
"""
```


<br>


## ORDER BY, GROUP BY, HAVING
  
<br>

### ORDER BY

`Select.order_by()`를 이용해 order_by()기능을 구현할 수 있고 오름차순, 내림차순은 
`ColumnElement.asc()``ColumnElement.desc()`를 
`order_by()` 인자값 앞에서 사용하면 됩니다.

```python
>>> print(select(user_table).order_by(user_table.c.name))
"""
SELECT user_account.id, user_account.name, user_account.fullname
FROM user_account ORDER BY user_account.name
"""

>>> print(select(User).order_by(User.fullname.desc()))
"""
SELECT user_account.id, user_account.name, user_account.fullname
FROM user_account ORDER BY user_account.fullname DESC
"""
```
<br>

### GROUP BY, Having을 이용한 집계함수 

SQL에서 집계 함수를 사용하면 여러 행에 걸쳐 있는 합쳐 단일 결과를 생성할 수 있습니다. 예를 들어 카운팅, 평균 계산은 물론 값 집합에서 최대값 또는 최소값을 찾는 작업을 할 수 있다. 

 SQLAlchemy는 func라고 하는 네임스페이스를 사용하여 SQL 함수를 개방형 방식으로 제공합니다. 이것은 특정 SQL 함수에 전달할 0개 이상의 인수가 지정된 경우 함수의 새 인스턴스를 만드는 특수 생성자 개체입니다. 예를 들어 user_account.id 열에 대해 SQL COUNT() 함수를 렌더링하려면 count() 이름을 호출합니다.


```python
>>> from sqlalchemy import func
>>> count_fn = func.count(user_table.c.id)
```

SQLAlchemy는 Select.group_by() 및 Select.having() 메서드를 사용하여 이 group_by와 having 기능을 제공합니다. 아래에서는 둘 이상의 주소를 가진 사용자에 대한 사용자 이름 필드 및 주소 수를 선택합니다.

```python
>>> with engine.connect() as conn:
...     result = conn.execute(
...         select(User.name, func.count(Address.id).label("count")).
...         join(Address).
...         group_by(User.name).
...         having(func.count(Address.id) > 1)
...     )
...     print(result.all())

[('sandy', 2)]
```

<br>


### 라벨을 통해 Ordering과 Grouping하기 

라벨을 통해 ordering, grouping하려면 스트링 텍스트의 이름을 `Select.order_by()` 또는 `Select.group_by()` 메서드에 전달하여 사용할 수 있습니다. 전달된 텍스트는 곧바로 렌더링되지 않습니다. 대신 컬럼절에 전잘 된 이름과 컨텍스트에 전달 된 이름이 일치하지 않으면 오류가 발생합니다.

```python
>>> from sqlalchemy import func, desc
>>> stmt = select(
...         Address.user_id,
...         func.count(Address.id).label('num_addresses')).\
...         group_by("user_id").order_by("user_id", desc("num_addresses"))
```
<br>


## 별칭 사용하기

<br>

### ORM 엔티티 별칭

 SQLAlchemy에서  as 구문을 통해 만들어진 이름들은  `FromClause` 객체를 사용하여 Core에 구성된 `FromClause.alias() method`
 를 이용하여 사용자에게 보여집니다.
  
SQLAlchemy에서는 별칭들은 `FromClause.Alias`생성자로 사용가능합니다.
`Alias`생성자는 Alias.c 컬렉션 내에 `Column`객체 네임스페이스도 있다는 점에서 `Table`생성자와 비슷합니다.

```python
>>> user_alias_1 = user_table.alias()
>>> user_alias_2 = user_table.alias()
```

<br>

## 서브쿼리와 CTE

이 섹션에서는 일반적으로 SELECT의 FROM 절에 있는 서브 쿼리에 대해 설명합니다. 서브쿼리와 유사한 방식으로 사용되지만 추가 기능이 포함된 CTE도 다룹니다.

SQLAlchemy는 `Subquery` 개체를 
`Select.subquery()`사용하여 서브 쿼리를 나타내고 `Select.cte()` 를 사용하여 CTE를 나타냅니다. 

```python
>>> subq = select(
...     func.count(address_table.c.id).label("count"),
...     address_table.c.user_id
... ).group_by(address_table.c.user_id).subquery()

>>> stmt = select(
...    user_table.c.name,
...    user_table.c.fullname,
...    subq.c.count
... ).join_from(user_table, subq) # ON절은 두 개의 테이블이 이미 foreigh key로 제약이 걸려있어 자동 바인딩된다.

```
<br>

### 계층 쿼리 
SQLAlchemy에서 CTE 구문을 사용하는 방법은 서브 쿼리 구문이 사용되는 방식과 거의 동일합니다. 대신 `Select.subquery()` 메서드의 호출을 Select.cte()를 사용하도록 변경하여 결과 객체를 FROM 요소로 사용할 수 있습니다. 

```python
>>> subq = select(
...     func.count(address_table.c.id).label("count"),
...     address_table.c.user_id
... ).group_by(address_table.c.user_id).cte()

>>> stmt = select(
...    user_table.c.name,
...    user_table.c.fullname,
...    subq.c.count
... ).join_from(user_table, subq)
```

<br>


### ORM 엔티티 서브쿼리/CTE
여기서는 `aliased()`가 `Subquery`, `CTE`서브 쿼리에 대해 동일한 작업을 수행하는 과정을 확인할 수 있습니다.

```python
>>> subq = select(Address).where(~Address.email_address.like('%@aol.com')).subquery()
>>> address_subq = aliased(Address, subq)
>>> stmt = select(User, address_subq).join_from(User, address_subq).order_by(User.id, address_subq.id)
>>> with Session(engine) as session:
...     for user, address in session.execute(stmt):
...         print(f"{user} {address}")
```
아래는 CTE생성자를 이용해 위와 같은  사용하는 예제입니다
```python
>>> cte = select(Address).where(~Address.email_address.like('%@aol.com')).cte()
>>> address_cte = aliased(Address, cte)
>>> stmt = select(User, address_cte).join_from(User, address_cte).order_by(User.id, address_cte.id)
>>> with Session(engine) as session:
...     for user, address in session.execute(stmt):
...         print(f"{user} {address}")

User(id=1, name='spongebob', fullname='Spongebob Squarepants') Address(id=1, email_address='spongebob@sqlalchemy.org')
User(id=2, name='sandy', fullname='Sandy Cheeks') Address(id=2, email_address='sandy@sqlalchemy.org')
User(id=2, name='sandy', fullname='Sandy Cheeks') Address(id=3, email_address='sandy@squirrelpower.org')
```
<br>


## 스칼라 쿼리, 상호연관 쿼리 

스칼라 서브 쿼리는 0 또는 1개의 ROW와 1개의 컬럼을 반환하는 서브 쿼리입니다. 
이 스칼라 서브 쿼리는 FROM 절에서 사용되지 않고 SELECT, COLUMNS절에서 사용된다는 점에서 일반 서브쿼리와 다릅니다.
상호연관 쿼리는 SELECT 절에 있는 테이블을 참조하는 스칼라 서브 쿼리입니다.

SQLAlchemy에서 스칼라 서브 쿼리는 `ColumnElement`계층의 일부인 `ScalarSelect` 구성을 사용하는 방면
반면 일반 서브 쿼리는`FromClause` 계층에 있는 `Subquery` 생성자를 사용합니다.

```python
>>> subq = select(func.count(address_table.c.id)).
...             where(user_table.c.id == address_table.c.user_id).
...             scalar_subquery()
```
 상호 연관 쿼리는 일반적으로 원하는 작업을 수행합니다. 그러나 상관 관계가 모호할 경우 SQLAlchemy는 더 명확한 설명이 필요하다는 것을 에러를 통해 알려줍니다.
```python
>>> stmt = select(
...     user_table.c.name,
...     address_table.c.email_address,
...     subq.label("address_count")
... ).\
... join_from(user_table, address_table).\
... order_by(user_table.c.id, address_table.c.id)
>>> print(stmt) #에러 발생 
```

스칼라 서브 쿼리는 자체적으로 문자열화될 때 FROM 절에서 user_account와 address를 모두 렌더링하지만 user_account 테이블을 처리하는 둘러싸는 select() 구문에 포함할 때 user_account 테이블은 자동으로 연결되므로 서브 쿼리의 FROM 절에서 렌더링되지 않습니다.

```python
>>> subq = select(func.count(address_table.c.id)).
...             where(user_table.c.id == address_table.c.user_id).
...             scalar_subquery().correlate(user_table)

>>> with engine.connect() as conn:
...     result = conn.execute(
...         select(
...             user_table.c.name,
...             address_table.c.email_address,
...             subq.label("address_count")
...         ).
...         join_from(user_table, address_table).
...         order_by(user_table.c.id, address_table.c.id)
...     )
...     print(result.all())
```

<br>


## UNION, UNION ALL 연산자들
SQL에서 SELECT 문은 UNION 또는 UNION ALL을 수행하여 결과물을 합칠 수 있으며 하나 이상의 쿼리에서 생성된 모든 행들을 집합을 생성합니다. `INTERSECT [ALL], EXCREST [ALL]`도 같은 역할을 수행할 수 있다. 

SQLAlchemy의 `Select` 생성자는 `union(), crossect(), except_all(),union_all(), crossect_all() ,except_all()`를 지원합니다.

이러한 함수로 생성되는 함수는 `CompoundSelect`이며, 이는 메서드가 더 적다는 점을 제외하고 `Select`와 비슷한 동일한 방식으로 사용됩니다.
```python
>>> from sqlalchemy import union_all
>>> stmt1 = select(user_table).where(user_table.c.name == 'sandy')
>>> stmt2 = select(user_table).where(user_table.c.name == 'spongebob')
>>> u = union_all(stmt1, stmt2)
>>> with engine.connect() as conn:
...     result = conn.execute(u)
...     print(result.all())
```
`CompoundSelect`를 하위 쿼리로 사용하려면 `SelectBase.subquery()` 메서드를 사용하여 FromClause.c 컬렉션을 생성하는 Subquery() 메서드를 제공합니다.

```python
>>> u_subq = u.subquery()
>>> stmt = (
...     select(u_subq.c.name, address_table.c.email_address).
...     join_from(address_table, u_subq).
...     order_by(u_subq.c.name, address_table.c.email_address)
... )
>>> with engine.connect() as conn:
...     result = conn.execute(stmt)
...     print(result.all())
```

<br>

## EXISTS 서브쿼리들

SQL EXISTS 키워드는  SELECT 문이 행을 반환하는지 여부에 따라 True 또는 false를 반환합니다.
 EXISTS 키워드 스칼라 서브 쿼리와 함께 사용되는 연산자입니다.

SQLAlchemy는 ScalarSelect 객체의 종류 중 하나로 Exists 객체를 갖고 있는데 이는 EXISTS 서브쿼리를 생성하고 SelectBase.exists()라는 메서드를 통해 Exists객첼르 생성할 수 있습니다.

```python
>>> subq = (
...     select(func.count(address_table.c.id)).
...     where(user_table.c.id == address_table.c.user_id).
...     group_by(address_table.c.user_id).
...     having(func.count(address_table.c.id) > 1)
... ).exists()
>>> with engine.connect() as conn:
...     result = conn.execute(
...         select(user_table.c.name).where(subq)
...     )
...     print(result.all())

[('sandy',)]
```

한편 EXISTS 구문은 부정으로 사용되지 않는 경우가 더 많습니다.
```python
# 이메일 주소가 없는 유저네임을 선택하는 쿼리문입니다.
# "~" 연산이 들어간 부분을 확인해보세요
>>> subq = (
...     select(address_table.c.id).
...     where(user_table.c.id == address_table.c.user_id)
... ).exists()
>>> with engine.connect() as conn:
...     result = conn.execute(
...         select(user_table.c.name).where(~subq) 
...     )
...     print(result.all())
```

<br>


## SQL 함수 다뤄보기
SQL 함수 작업
이 섹션 앞부분의 GROUP BY / HAVING을 사용한 집계 함수에서 처음 소개된 `func` 객체는
새로운 `Function` 객체를 생성하기 위한 팩토리 역할을 합니다.  
여기서 `Function` 객체는 `select()`와 같은 구문을 사용 할 때   
이름,괄호(항상 그렇지는 않지만) 종종 인자값등 으로 구성된 SQL 함수를 생성합니다.  
일반적인 SQL 함수는 다음과 같습니다.


- `count()` : 집계 함수로 몇개의 행이 반환되었지 세서 그 수를 반환해줍니다.
  ```python
  >>> print(select(func.count()).select_from(user_table))
  
  SELECT count(*) AS count_1FROM user_account
  ```
- `lower()` : 문자열 함수로 스트링 문자열을 소문자로 바꿔줍니다.
  ```python
  >>> print(select(func.lower("A String With Much UPPERCASE")))
  
  SELECT lower(:lower_2) AS lower_1
  ```
- `now()` : 현재 시간과 날짜를 반환해주는 함수입니다. 
  이 함수는 굉장히 흔하게 사용되는 함수이기에 SQLAlchemy는 서로 다른 백엔드에서 손쉽게 렌더링 할 수 있도록 도와줍니다. 
  ```` python
  #SQLite에서 CURRENT_TIMESTAMP함수로 쓰일 경우 
  >>> stmt = select(func.now())
  >>> with engine.connect() as conn:
  ...     result = conn.execute(stmt)
  ...     print(result.all())
  ````

<br> 

### 리턴 타입이 있는 함수Functions Have Return Types

SQL에서도 데이터 타입이 있는데 SQLAlchemy에서는 "SQL 리턴 타입"이라고 말합니다.

아래와 `Function.type`속성을 이용해 SQL 함수의 SQL 리턴타입을 확인 할 수 있습니다.
```python
>>> func.now().type
DateTime()
```

이러한 SQL 리턴 유형은 길이가 긴 쿼리에서 함수 표현식을 사용할 때 중요합니다.
예를 들면 수학 연산자는 표현식의 데이터 유형이 `Integer` 또는 `Numeric` 
일때 더 잘 작동되고 JSON 접근자를 처리하려면 `JSON` 타입을 사용해야합니다.

한편 특정 클래스의 함수는 특정 열을 참조해야 하는 경우 컬럼 값 대신 전체 행을 반환하는데 이러한 함수를
`table valued functions. `

함수에 특정 타입을 적용하려면 `Function.type_` 파라미터를 사용하여 전달해야합니다. 
타입 인수는 `TypeEngine`의 클래스 또는 인스턴스일 수 있습니다.
아래 예제에서 `JSON` 클래스를 전달하여 PostgreSQL `json_object()`
함수를 생성합니다. 이때 SQL 리턴 타입은 JSON 유형이 됩니다.

```python
>>> from sqlalchemy import JSON
>>> function_expr = func.json_object('{a, 1, b, "def", c, 3.5}', type_=JSON)
>>> stmt = select(function_expr["def"])
>>> print(stmt)
"""
SELECT json_object(:json_object_1)[:json_object_2] AS anon_1
"""
```


<br> 

### Built-in Functions Have Pre-Configured Return Types
> 원문의 Built-in Functions Have Pre-Configured Return Types 부분은 제가 이해하지 못했습니다. 
> 이에 대해 이해하신 분 있으시다면 이 부분에 기여 부탁드립니다. 감사합니다.


<br> 

### 윈도우 함수

SQLAlchemy에서는, `func` 네임스페이스에 의해 생성된 모든 SQL 함수에는
윈도우 함수 또는 "OVER 구문을 부여하는  `FunctionElement.over()` 메서드가 포함되어 있습니다.


윈도우 함수와 함께 사용되는 일반적인 함수는 단순히 행을 계산하는 row_number() 함수입니다.

```python
# FunctionElement.over.partition_by파라미터는를 사용하여 
# PARTITION BY 절이 OVER 절에 렌더링되도록 했습니다.

>>> stmt = select(
...     func.row_number().over(partition_by=user_table.c.name),
...     user_table.c.name,
...     address_table.c.email_address
... ).select_from(user_table).join(address_table)
>>> with engine.connect() as conn:  
...     result = conn.execute(stmt)
...     print(result.all())
# 이 행을 사용자 이름에 대해 분할하여 각 각의 사용자이메일 주소에 번호를 매길 수 있습니다.
[(1, 'sandy', 'sandy@sqlalchemy.org'), 
 (2, 'sandy', 'sandy@squirrelpower.org'), 
 (1, 'spongebob', 'spongebob@sqlalchemy.org')]
```
`FunctionElement.over.order_by`를 사용하여 ORDER BY 절을 사용할 수도 있습니다.
```python
>>> stmt = select(
...     func.count().over(order_by=user_table.c.name),
...     user_table.c.name,
...     address_table.c.email_address).select_from(user_table).join(address_table)
>>> with engine.connect() as conn:  
...     result = conn.execute(stmt)
...     print(result.all())

[(2, 'sandy', 'sandy@sqlalchemy.org'), 
 (2, 'sandy', 'sandy@squirrelpower.org'), 
 (3, 'spongebob', 'spongebob@sqlalchemy.org')]
```
<br> 

### WITHIN GROUP, FILTER등 특수한 지정자

"WITHIN GORUP"이라는 SQL 구문은 순서 집합 또는 가상 집합 그리고 집계함수와 함께 쓰입니다.
일반적인 순서 집합 함수는 `percentile_cont()(` 그리고 `rank()`를 포함하고 있습니다.
SQLAlchemy에서는 `rank, dense_rank, percentile_count, percentile_disc`가 구현되어 있고
각 각은 `FunctionElement.within_group()`메서드를 갖고 있습니다.

```python
>>> print(
...     func.unnest(
...         func.percentile_disc([0.25,0.5,0.75,1]).within_group(user_table.c.name)
...     )
... )

unnest(percentile_disc(:percentile_disc_1) WITHIN GROUP (ORDER BY user_account.name))
```
어떤 백엔드에서는 "FILTER"를 지원하는데 이는 ` FunctionElement.filter()`메서드로 
사용이 가능합니다. 
```python
>>> stmt = select(
...     func.count(address_table.c.email_address).filter(user_table.c.name == 'sandy'),
...     func.count(address_table.c.email_address).filter(user_table.c.name == 'spongebob')
... ).select_from(user_table).join(address_table)
>>> with engine.connect() as conn:  
...     result = conn.execute(stmt)
...     print(result.all())

[...] ('sandy', 'spongebob')
[(2, 1)]
```

<br> 

### Table-Valued Functions
> 원문의 Table-Valued Functions 부분은 제가 이해하지 못했습니다. 
> 이에 대해 이해하신 분 있으시다면 이 부분에 기여 부탁드립니다. 감사합니다.



### 컬럼-값 함수
Oracle과 PostgresSQL에서 지원하는 특별 문법 중 하나로 FROM절을 참조하는 함수가 있습니다.
이 함수는 FROM절을 참조한 다음 SELECT 절에 있는 하나의 컬럼으로 자기 자신(함수)를 전달 할 수 있습니다.
PostgreSQL에서는 json_array_elements(), json_object_keys(), json_each_text(), json_each()등의 함수로 쓸 수 있습니다.
한편 SQLAlchemy는 이것을 컬럼 값이라고 하며 `FunctionElement.column_valued()`지정자를 적용하여 사용할 수 있습니다.
```python
>>> from sqlalchemy import select, func
>>> stmt = select(func.json_array_elements('["one", "two"]').column_valued("x"))
>>> print(stmt)
"""
SELECT x
FROM json_array_elements(:json_array_elements_1) AS x
"""
```

컬럼값의 형태는 오라클 방언에서 지원되는데 이는 커스텀 SQL 함수에서 사용할 수 있습니다.

```python
>>> from sqlalchemy.dialects import oracle
>>> stmt = select(func.scalar_strings(5).column_valued("s"))
>>> print(stmt.compile(dialect=oracle.dialect()))
"""
SELECT COLUMN_VALUE s
FROM TABLE (scalar_strings(:scalar_strings_1)) s
"""
```
