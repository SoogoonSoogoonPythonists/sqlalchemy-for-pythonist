# 5. 데이터 select하기 

<br>

Core와 ORM을 이용해 데이터 Select하기 - 이번 섹션은 SQLAlchemy에서 가장 자주 쓰이느 Select 생성자에 대해서 다룹니다. Select 생성자는 Core 및 ORM을 이용한 어플리케이션 구문을 반환합니다.

<br>

## select() SQL 구문 생성자
select() 생성자는 insert() 생성자와 같은 방식으로 쿼리문을 만들 수 있습니다.

```python
>>> from sqlalchemy import select
>>> stmt = select(user_table).where
# name 컬럼에 접근하고 싶다면 테이블명.c.name
(user_table.c.name == 'spongebob')
>>> print(stmt)
```

마찬가지로 쿼리문을 실행시키 위해 같은 레벨의 SQL 생성자들(select, insert, update, create등)처럼 execution 메서드에 쿼리를 넣어 실행시킬 수 있습니다.

```python
>>> with engine.connect() as conn:
...     for row in conn.execute(stmt):
...         print(row)
(1, 'spongebob', 'Spongebob Squarepants')
```

한편 ORM을 이용해 select() 생성자를 사용할 때는 <code>Session.exeucte()</code>를 사용해야합니다.
결과는 마찬가지로 <code>Row</code>객체를 반환하지만
완전한 엔티티를 포함하는 결과를 반환합니다.

```python
>>> stmt = select(User).where(User.name == 'spongebob')
# User 클래스의 인스턴스 안에 있는 각 row 들을 출력
>>> with Session(engine) as session:
...     for row in session.execute(stmt):
...         print(row)

```

<br>

## COLUMNS과 FROM절 세팅하기

select로 선택하고 싶은 컬럼들 혹은 테이블을 
select() 함수의 인자로도 사용할 수 있습니다.


각 컬럼들을 Core를 이용해 조회하고자
<code>Table.c</code> 접근자(accessor)에서 <code>column</code>객체에 접근합니다.


<br>

### ORM 엔티티와 and 컬럼 조회하기

 ORM <code>Session.execute()</code>메서드를 이용해 쿼리문을 실행 시킬 때 <code>User</code> 클래스와 같은 전체 엔티티를 사용하면 결과 세트에서 
 각 row에 엔티티가 포함되어 리턴이 됩니다.

```python
>>> row = session.execute(select(User)).first

>>> row[0]
User(id=1, name='spongebob', fullname='Spongebob Squarepants')
```

또는 클래스 바인딩 어트리뷰트를 사용하여 결과물 <code>row</code>내의 ORM 엔티티 컬럼을 select 할 수 있습니다.

```python
>>> prow = session.execute(select(User.name, User.fullname)).first()
>>> row
('spongebob', 'Spongebob Squarepants')
```

또는 믹스인 방식으로, 행의 첫 번째 요소에는 User entity의 이름 속성을 선택하고 두 번째 요소의 전체 Address entity를 넣어 다음과 같은 접근 방식도 혼용할 수 있습니다.


```python
>>> session.execute(
...     select(User.name, Address).
...     where(User.id==Address.user_id).
...     order_by(Address.id)
... ).all()

[('spongebob', Address(id=1, email_address='spongebob@sqlalchemy.org')),
('sandy', Address(id=2, email_address='sandy@sqlalchemy.org')),
('sandy', Address(id=3, email_address='sandy@squirrelpower.org'))]
```

<br>

### 라벨링된 데이터 조회하기

<code>ColumnElement.label() </code>는  SQL 
쿼리 실행 결과물에서 컬럼에 특정한 이름(라벨)을 지을 수 있게 도와줍니다. 이러한 라벨은 결과물 세트에서 각 row에서 참조할 수도 있습니다.

```python
>>> from sqlalchemy import func, cast
>>> stmt = (
...     select(
...         ("Username: " + user_table.c.name).label("username"),
...     ).order_by(user_table.c.name)
... )
>>> with engine.connect() as conn:
...     for row in conn.execute(stmt):
...         print(f"{row.username}")
Username: patrick
Username: sandy
Username: spongebob
```

### 스트링 데이터 조회하기

보통 <code>Select</code>객체나 <code>select()</code> 생성자를 이용 할 때는 컬럼을 조회하는 경우가 다수지만 가끔은 임의로 스트링 문자열과 함께 컬럼을 조회를 해야하는 경우가 있습니다. 이번 섹션에서는 스트링 데이터를 조회 하는 방법에 다룹니다.

아래는 text() 생성자를 이용해 `some label`과 함께 특정 컬럼을 같이 출력하는 예제입니다.

```python
>>> from sqlalchemy import text
>>> stmt = (
...     select(
...         text("'some phrase'"), user_table.c.name
...     ).order_by(user_table.c.name)
... )
>>> with engine.connect() as conn:
...     print(conn.execute(stmt).all())

('some phrase', 'patrick'), ('some phrase', 'sandy'), ('some phrase', 'spongebob')]
```

하지만 일반적으로 literal_column() 생성자를 이용하면 스트링 문자열을 출력하는데 더 편리한 기능을 제공해줍니다.
이 생성자는 text() 와 매우 비슷하지만, 
임의로 SQL 형식을 출력하기보다 보다 명시적으로 하나의
<code>column</code>을 표시하고 서브쿼리를 이용 할 수 있게 라벨 기능을을 제공합니다.

```python
>>> from sqlalchemy import literal_column
>>> stmt = (
...     select(
...         literal_column("'some phrase'").label("p"), user_table.c.name
...     ).order_by(user_table.c.name)
... )
>>> with engine.connect() as conn:
...     for row in conn.execute(stmt):
...         print(f"{row.p}, {row.name}")
some phrase, patrick
some phrase, sandy
some phrase, spongebob

```

> 하지만 text() 또는 literal_column()을 사용한다는 것은  때는 리터럴 값이 아닌 SQL 구문을 사용한다는 뜻입니다. 따라서 우리는 렌더링하려는 SQL에 필요한 ""와 같은 쌍따옴표등을 추가해야합니다.

## WHERE절

SQLAlchemy를 사용하면 Python 연산자를 사용하여 이름 = 'thead' 또는 user_id > 10과 같은 SQL 식을 작성할 수 있습니다.

```python
>>> print(user_table.c.name == 'squidward')
user_account.name = :name_1

>>> print(address_table.c.user_id > 10)
address.user_id > :user_id_1

where 절을 통한 join을 구현 할 경우 아래와 같이 작성 가능합니다.
```python
>>> select(address_table.c.email_address)
...     where(user_table.c.name == 'squidward').
...     where(address_table.c.user_id == user_table.c.id)
... 


>>> # 위와 같은 표현
...     select(address_table.c.email_address).
...     where(
...          user_table.c.name == 'squidward',
...          address_table.c.user_id == user_table.c.id
...     )
...
```

and_(), or_()등의 연결 구문도 구현가능합니다.

```python
>>> from sqlalchemy import and_, or_
>>>     select(Address.email_address).
...     where(
...         and_(
...             or_(User.name == 'squidward', User.name == 'sandy'),
...             Address.user_id == User.id
...         )
...     )
... 
```

단순히 같은지, 아닌지 비교하는 경우(equality) <code>Select.filter_by()</code>도 자주 사용됩니다.
```python
>>>select(User).filter_by(name='spongebob', fullname='Spongebob Squarepants')
```

<br>

## FROM절과 JOIN 명시하기

FROM 절은 보통 Select의 선택된 컬럼들에 있는 테이블을 렌더링한다.(table_name.column)

>>> print(select(user_table.c.name, address_table.c.email_address)) # 두 개의 테이블 참조
```

join을 이용해 두 개 이상의 테이블을 참조해 select 해야하는 경우가 있는데 이 상황에서 두 개의 메서드를 선택할 수 있다.
첫 째는 <code>Select.join_from()</code>로 
JOIN구문에서 명시적으로 왼쪽테이블, 오른쪽 테이블을 지정할 수 있게 한다.
두 번째는  <code>Select.join()</code>로 오직 오른쪽 테이블만 명시되어 있다.

```python
>>>     select(user_table.c.name, address_table.c.email_address).
...     join(address_table)
```

한편 우리가 FROM절에 추가 옵션을 주고 싶을 때는 Select.select_frim()메서드를 사용한다.

```python
>>> print(
...     select(address_table.c.email_address).
...     select_from(user_table).join(address_table)
... )


SELECT address.email_address
FROM user_account JOIN address ON user_account.id = address.user_id
```

추가로 우리가 select 하고자 하는 컬럼들에 우리가 받아오고 싶은 컬럼이 없다면 <code>sqlalchemy.sql.expression.func</code>를 이용 할 수 있습니다.

```python
>>> from sqlalchemy import func
>>> print(select(func.count('*')).select_from(user_table))
...
...
SELECT count(:count_2) AS count_1
FROM user_account
```

### On절 세팅하기

이 전의 예제에서는 <code>Select</code>가 두 테이블을 조인하고 자동으로  ON절을 생성할 수 있음을 확인했습니다. 하지만 이는 <code>user_table</code>, <code>address_table</code>에 ForeignKeyConstraint 정의가 포함되어 있어서 가능한 것이었습니다.

만약에 Join의 대상인 왼쪽 테이블과 오른쪽 테이블이 이러한 제약 key가 없다거나 여러개의 key를 필요로 할 경우 ON 절을 직접 지정해야 합니다. 이러한 기능은 Select.join()과 Select 둘 다 제공하고 join_from()은 ON 절에 대한 추가 인수를 허용합니다.

```python
>>> print(
...     select(address_table.c.email_address).
...     select_from(user_table).
...     join(address_table, user_table.c.id == address_table.c.user_id)
... )

SELECT address.email_address
FROM user_account JOIN address ON user_account.id = address.user_id
```

### OUTER, FULL Join

<code>Select.join()</code>과 <code>Select.join_from()</code>메서드 둘 다 키워드 인자로 <code>Select.join.isouter</code>,
<code>Select.join.full </code>를 받고 이를 각 각
LEFT OUTER JOIN, FULL OUTER JOIN으로 렌더링 합니다.

```python
>>> print(
...     select(user_table).join(address_table, isouter=True)
... )

SELECT user_account.id, user_account.name, user_account.fullname
FROM user_account LEFT OUTER JOIN address ON user_account.id = address.user_id
```

## ORDER BY, GROUP BY, HAVING

- ORDER BY :  select된 rows의 결과를 특정 순서로 반환하는 역할
- GROUP BY : select된 rows의 결과를 또 서브 그룹으로 나누어서 반환하는 역할 
- HAVING : GROUP BY + WHERE가 섞인 기능을 구현하지만 이미 GROUPING된 결과물을 안에서 WHERE절을 사용하는 것과 같다.
  
### ORDER BY

<code>Select.order_by()</code>를 이용해 order_by()기능을 구현할 수 있고 오름차순, 내림차순은 
<code>ColumnElement.asc()</code><code>ColumnElement.desc()</code>를 
<code>order_by()</code> 인자값 앞에서 사용하면 됩니다.

```python
>>> print(select(user_table).order_by(user_table.c.name))

SELECT user_account.id, user_account.name, user_account.fullname
FROM user_account ORDER BY user_account.name

>>> print(select(User).order_by(User.fullname.desc()))

SELECT user_account.id, user_account.name, user_account.fullname
FROM user_account ORDER BY user_account.fullname DESC
```

### GROUP BY, Having을 이용한 집계함수 

SQL에서 집계 함수를 사용하면 여러 행에 걸쳐 있는 합쳐 단일 결과를 생성할 수 있습니다. 예를 들어 카운팅, 평균 계산은 물론 값 집합에서 최대값 또는 최소값을 찾는 작업을 할 수 있다. 

 SQLAlchemy는 func라고 하는 네임스페이스를 사용하여 SQL 함수를 개방형 방식으로 제공한다. 이것은 특정 SQL 함수에 전달할 0개 이상의 인수가 지정된 경우 함수의 새 인스턴스를 만드는 특수 생성자 개체입니다. 예를 들어 user_account.id 열에 대해 SQL COUNT() 함수를 렌더링하려면 count() 이름을 호출한다.


```python
>>> from sqlalchemy import func
>>> count_fn = func.count(user_table.c.id)
```

SQLAlchemy는 Select.group_by() 및 Select.having() 메서드를 사용하여 이 group_by와 having 기능을 제공합니다. 아래에서는 둘 이상의 주소를 가진 사용자에 대한 사용자 이름 필드 및 주소 수를 선택합니다.

```python
>>> with engine.connect() as conn:
...     result = conn.execute(
...         select(User.name, func.count(Address.id).label("count")).
...         join(Address).
...         group_by(User.name).
...         having(func.count(Address.id) > 1)
...     )
...     print(result.all())

[('sandy', 2)]
```

### 라벨을 통해 Ordering or Grouping하기 

라벨을 통해 ordering, grouping하려면 스트링 텍스트의 이름을 <code>Select.order_by()</code> 또는 <code>Select.group_by()</code> 메서드에 전달하여 사용할 수 있습니다. 전달된 텍스트는 곧바로 렌더링되지 않습니다. 대신 컬럼절에 전잘 된 이름과 컨텍스트에 전달 된 이름이 일치하지 않으면 오류가 발생합니다.

```python
>>> from sqlalchemy import func, desc
>>> stmt = select(
...         Address.user_id,
...         func.count(Address.id).label('num_addresses')).\
...         group_by("user_id").order_by("user_id", desc("num_addresses"))
```


## 별칭 사용하기


### ORM Entity Aliases

 SQLAlchemy에서  as 구문을 통해 만들어진 이름들은  <code>FromClause</code> 객체를 사용하여 Core에 구성된 <code>FromClause.alias() method</code>
 를 이용하여 사용자에게 보여진다.
  
SQLAlchemy에서는 별칭들은 <code>FromClause.Alias</code>생성자로 사용가능합니다.
<code>Alias</code>생성자는 Alias.c 컬렉션 내에 <code>Column</code>객체 네임스페이스도 있다는 점에서 <code>Table</code>생성자와 비슷합니다.

```python
>>> user_alias_1 = user_table.alias()
>>> user_alias_2 = user_table.alias()
```

<br>

## 서브쿼리와 and CTEs

이 섹션에서는 일반적으로 SELECT의 FROM 절에 있는 서브 쿼리에 대해 설명합니다. 서브쿼리와 유사한 방식으로 사용되지만 추가 기능이 포함된 CTE도 다룹니다.

SQLAlchemy는 <code>Subquery</code> 개체를 
<code>Select.subquery()</code>사용하여 서브 쿼리를 나타내고 <code>Select.cte()</code> 를 사용하여 CTE를 나타냅니다. 

```python
>>> subq = select(
...     func.count(address_table.c.id).label("count"),
...     address_table.c.user_id
... ).group_by(address_table.c.user_id).subquery()

>>> stmt = select(
...    user_table.c.name,
...    user_table.c.fullname,
...    subq.c.count
... ).join_from(user_table, subq) # ON절은 두 개의 테이블이 이미 foreigh key로 제약이 걸려있어 자동 바인딩된다.

```
### 계층 쿼리 
SQLAlchemy에서 CTE 구문을 사용하는 방법은 서브 쿼리 구문이 사용되는 방식과 거의 동일합니다. 대신 <code>Select.subquery()</code> 메서드의 호출을 Select.cte()를 사용하도록 변경하여 결과 객체를 FROM 요소로 사용할 수 있습니다. 

```python
>>> subq = select(
...     func.count(address_table.c.id).label("count"),
...     address_table.c.user_id
... ).group_by(address_table.c.user_id).cte()

>>> stmt = select(
...    user_table.c.name,
...    user_table.c.fullname,
...    subq.c.count
... ).join_from(user_table, subq)
```

### ORM 엔티티 서브쿼리/CTE
여기서는 <code>aliased()</code>가 <code>Subquery</code>, <code>CTE</code>서브 쿼리에 대해 동일한 작업을 수행하는 과정을 확인할 수 있습니다.

```python
>>> subq = select(Address).where(~Address.email_address.like('%@aol.com')).subquery()
>>> address_subq = aliased(Address, subq)
>>> stmt = select(User, address_subq).join_from(User, address_subq).order_by(User.id, address_subq.id)
>>> with Session(engine) as session:
...     for user, address in session.execute(stmt):
...         print(f"{user} {address}")
```
아래는 CTE생성자를 이용해 위와 같은  사용하는 예제입니다
```python
>>> cte = select(Address).where(~Address.email_address.like('%@aol.com')).cte()
>>> address_cte = aliased(Address, cte)
>>> stmt = select(User, address_cte).join_from(User, address_cte).order_by(User.id, address_cte.id)
>>> with Session(engine) as session:
...     for user, address in session.execute(stmt):
...         print(f"{user} {address}")

User(id=1, name='spongebob', fullname='Spongebob Squarepants') Address(id=1, email_address='spongebob@sqlalchemy.org')
User(id=2, name='sandy', fullname='Sandy Cheeks') Address(id=2, email_address='sandy@sqlalchemy.org')
User(id=2, name='sandy', fullname='Sandy Cheeks') Address(id=3, email_address='sandy@squirrelpower.org')
ROLLBACK
```


## 스칼라 쿼리, 상호연관 쿼리 

스칼라 서브 쿼리는 0 또는 1개의 ROW와 1개의 컬럼을 반환하는 서브 쿼리입니다. 
이 스칼라 서브 쿼리는 FROM 절에서 사용되지 않고 SELECT, COLUMNS절에서 사용된다는 점에서 일반 서브쿼리와 다릅니다.
상호연관 쿼리는 SELECT 절에 있는 테이블을 참조하는 스칼라 서브 쿼리입니다.

SQLAlchemy에서 스칼라 서브 쿼리는 <code>ColumnElement</code>계층의 일부인 <code>ScalarSelect</code> 구성을 사용하는 방면
반면 일반 서브 쿼리는<code>FromClause</code> 계층에 있는 <code>Subquery</code> 생성자를 사용합니다.

```python
>>> subq = select(func.count(address_table.c.id)).\
...             where(user_table.c.id == address_table.c.user_id).\
...             scalar_subquery()
```
 상호 연관 쿼리는 일반적으로 원하는 작업을 수행합니다. 그러나 상관 관계가 모호할 경우 SQLAlchemy는 더 명확한 설명이 필요하다는 것을 에러를 통해 알려줍니다.
```python
>>> stmt = select(
...     user_table.c.name,
...     address_table.c.email_address,
...     subq.label("address_count")
... ).\
... join_from(user_table, address_table).\
... order_by(user_table.c.id, address_table.c.id)
>>> print(stmt) #에러 발생 
```

Although the scalar subquery by itself renders both user_account and address in its FROM clause when stringified by itself, when embedding it into an enclosing select() construct that deals with the user_account table, the user_account table is automatically correlated, meaning it does not render in the FROM clause of the subquery:.

```python
>>> subq = select(func.count(address_table.c.id)).\
...             where(user_table.c.id == address_table.c.user_id).\
...             scalar_subquery().correlate(user_table)

>>> with engine.connect() as conn:
...     result = conn.execute(
...         select(
...             user_table.c.name,
...             address_table.c.email_address,
...             subq.label("address_count")
...         ).
...         join_from(user_table, address_table).
...         order_by(user_table.c.id, address_table.c.id)
...     )
...     print(result.all())
```

## UNION, UNION ALL and other set operations
SQL에서 SELECT 문은 UNION 또는 UNION ALL을 수행하여 결과물을 합칠 수 있으며 하나 이상의 쿼리에서 생성된 모든 행들을 집합을 생성한다.. <code>INTERSECT [ALL], EXCREST [ALL]</code>도 같은 역할을 수행할 수 있다. 

SQLAlchemy의 <code>Select</code> 생성자는 <code>union(), crossect(), except_all(),union_all(), crossect_all() ,except_all()</code>를 지원한다. 

이러한 함수로 생성되는 함수는 <code>CompoundSelect</code>이며, 이는 메서드가 더 적다는 점을 제외하고 <code>Select</code>와 비슷한 동일한 방식으로 사용됩니다.
```python
>>> from sqlalchemy import union_all
>>> stmt1 = select(user_table).where(user_table.c.name == 'sandy')
>>> stmt2 = select(user_table).where(user_table.c.name == 'spongebob')
>>> u = union_all(stmt1, stmt2)
>>> with engine.connect() as conn:
...     result = conn.execute(u)
...     print(result.all())
```
<code>CompoundSelect</code>를 하위 쿼리로 사용하려면 <code>SelectBase.subquery()</code> 메서드를 사용하여 FromClause.c 컬렉션을 생성하는 Subquery() 메서드를 제공합니다.
```python
>>> u_subq = u.subquery()
>>> stmt = (
...     select(u_subq.c.name, address_table.c.email_address).
...     join_from(address_table, u_subq).
...     order_by(u_subq.c.name, address_table.c.email_address)
... )
>>> with engine.connect() as conn:
...     result = conn.execute(stmt)
...     print(result.all())
```
