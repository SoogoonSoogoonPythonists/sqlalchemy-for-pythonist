# 5. 데이터 핸들링 - Core, ORM으로 행 조회하기

<br>

이번 섹션에서는 SQLAlchemy에서 가장 자주 쓰이는 Select에 대해서 다룹니다.

<br>

## select() SQL 구문 생성자
select() 생성자는 insert() 생성자와 같은 방식으로 쿼리문을 만들 수 있습니다.

```python
>>> from sqlalchemy import select
>>> stmt = select(user_table).where
>>>(user_table.c.name == 'spongebob')  # name 컬럼에 접근하고 싶다면 테이블명.c.name
>>> print(stmt)
"""
SELECT user_account.id, user_account.name, user_account.fullname
FROM user_account
WHERE user_account.name = :name_1
"""
```

마찬가지로 쿼리문을 실행시키 위해 같은 레벨의 SQL 생성자들(select, insert, update, create등)처럼 execution 메서드에 쿼리를 넣어 실행시킬 수 있습니다.

```python
>>> with engine.connect() as conn:
...     for row in conn.execute(stmt):
...         print(row)
(1, 'spongebob', 'Spongebob Squarepants')
```

한편 ORM을 이용해 select() 생성자를 사용할 때는 <code>Session.exeucte()</code>를 사용해야합니다.
결과는 마찬가지로 <code>Row</code>객체를 반환하지만
완전한 엔티티를 포함하는 결과를 반환합니다.

```python
>>> stmt = select(User).where(User.name == 'spongebob')
# User 클래스의 인스턴스 안에 있는 각 row 들을 출력
>>> with Session(engine) as session:
...     for row in session.execute(stmt):
...         print(row)

```

<br>

##  FROM절 세팅하기

select로 선택하고 싶은 컬럼들 혹은 테이블을 
select() 함수의 인자로도 사용할 수 있습니다.

각 컬럼들을 Core를 이용해 조회하고자
<code>Table.c</code> 접근자(accessor)에서 <code>column</code>객체에 접근합니다.

<br>


### ORM 엔티티와 and 컬럼 조회하기

 ORM <code>Session.execute()</code>메서드를 이용해 쿼리문을 실행 시킬 때 <code>User</code> 클래스와 같은 전체 엔티티를 사용하면 결과 세트에서 
 각 row에 엔티티가 포함되어 리턴이 됩니다.

```python
>>> row = session.execute(select(User)).first

>>> row[0]
User(id=1, name='spongebob', fullname='Spongebob Squarepants')
```

또는 클래스 바인딩 어트리뷰트를 사용하여 결과물 <code>row</code>내의 ORM 엔티티 컬럼을 select 할 수 있습니다.

```python
>>> prow = session.execute(select(User.name, User.fullname)).first()
>>> row
('spongebob', 'Spongebob Squarepants')
```

또는 믹스인 방식으로, 행의 첫 번째 요소에는 User entity의 이름 속성을 선택하고 두 번째 요소의 전체 Address entity를 넣어 다음과 같은 접근 방식도 혼용할 수 있습니다.


```python
>>> session.execute(
...     select(User.name, Address).
...     where(User.id==Address.user_id).
...     order_by(Address.id)
... ).all()

[('spongebob', Address(id=1, email_address='spongebob@sqlalchemy.org')),
('sandy', Address(id=2, email_address='sandy@sqlalchemy.org')),
('sandy', Address(id=3, email_address='sandy@squirrelpower.org'))]
```

<br>

### 라벨링된 데이터 조회하기

<code>ColumnElement.label() </code>는  SQL 
쿼리 실행 결과물에서 컬럼에 특정한 이름(라벨)을 지을 수 있게 도와줍니다. 이러한 라벨은 결과물 세트에서 각 row에서 참조할 수도 있습니다.

```python
>>> from sqlalchemy import func, cast
>>> stmt = (
...     select(
...         ("Username: " + user_table.c.name).label("username"),
...     ).order_by(user_table.c.name)
... )
>>> with engine.connect() as conn:
...     for row in conn.execute(stmt):
...         print(f"{row.username}")
Username: patrick
Username: sandy
Username: spongebob
```

<br>

### 스트링 데이터 조회하기

보통 <code>Select</code>객체나 <code>select()</code> 생성자를 이용 할 때는 컬럼을 조회하는 경우가 다수지만 가끔은 임의로 스트링 문자열과 함께 컬럼을 조회를 해야하는 경우가 있습니다. 이번 섹션에서는 스트링 데이터를 조회 하는 방법에 다룹니다.

아래는 text() 생성자를 이용해 `some label`과 함께 특정 컬럼을 같이 출력하는 예제입니다.

```python
>>> from sqlalchemy import text
>>> stmt = (
...     select(
...         text("'some phrase'"), user_table.c.name
...     ).order_by(user_table.c.name)
... )
>>> with engine.connect() as conn:
...     print(conn.execute(stmt).all())

('some phrase', 'patrick'), ('some phrase', 'sandy'), ('some phrase', 'spongebob')]
```

하지만 일반적으로 literal_column() 생성자를 이용하면 스트링 문자열을 출력하는데 더 편리한 기능을 제공해줍니다.
이 생성자는 text() 와 매우 비슷하지만, 
임의로 SQL 형식을 출력하기보다 보다 명시적으로 하나의
<code>column</code>을 표시하고 서브쿼리를 이용 할 수 있게 라벨 기능을을 제공합니다.

```python
>>> from sqlalchemy import literal_column
>>> stmt = (
...     select(
...         literal_column("'some phrase'").label("p"), user_table.c.name
...     ).order_by(user_table.c.name)
... )
>>> with engine.connect() as conn:
...     for row in conn.execute(stmt):
...         print(f"{row.p}, {row.name}")
some phrase, patrick
some phrase, sandy
some phrase, spongebob

```

> 하지만 text() 또는 literal_column()을 사용한다는 것은  때는 리터럴 값이 아닌 SQL 구문을 사용한다는 뜻입니다. 따라서 우리는 렌더링하려는 SQL에 필요한 ""와 같은 쌍따옴표등을 추가해야합니다.

<br>

## WHERE절

SQLAlchemy를 사용하면 Python 연산자를 사용하여 이름 = 'thead' 또는 user_id > 10과 같은 SQL 식을 작성할 수 있습니다.

```python
>>> print(user_table.c.name == 'squidward')
user_account.name = :name_1

>>> print(address_table.c.user_id > 10)
address.user_id > :user_id_1

where 절을 통한 join을 구현 할 경우 아래와 같이 작성 가능합니다.
```python
>>> select(address_table.c.email_address)
...     where(user_table.c.name == 'squidward').
...     where(address_table.c.user_id == user_table.c.id)
... 


>>> # 위와 같은 표현
...     select(address_table.c.email_address).
...     where(
...          user_table.c.name == 'squidward',
...          address_table.c.user_id == user_table.c.id
...     )
...
```

and_(), or_()등의 연결 구문도 구현가능합니다.

```python
>>> from sqlalchemy import and_, or_
>>>     select(Address.email_address).
...     where(
...         and_(
...             or_(User.name == 'squidward', User.name == 'sandy'),
...             Address.user_id == User.id
...         )
...     )
... 
```

단순히 같은지, 아닌지 비교하는 경우(equality) <code>Select.filter_by()</code>도 자주 사용됩니다.
```python
>>>select(User).filter_by(name='spongebob', fullname='Spongebob Squarepants')
```

<br>

## FROM절과 JOIN 명시하기

FROM 절은 보통 Select의 선택된 컬럼들에 있는 테이블을 렌더합니다.(table_name.column)

join을 이용해 두 개 이상의 테이블을 참조해 select 해야하는 경우가 있는데 이 상황에서 두 개의 메서드를 선택할 수 있다.
첫 째는 <code>Select.join_from()</code>로 
JOIN구문에서 명시적으로 왼쪽테이블, 오른쪽 테이블을 지정할 수 있게 합니다.
두 번째는  <code>Select.join()</code>로 오직 오른쪽 테이블만 명시되어 있다.

>>> print(select(user_table.c.name, address_table.c.email_address)) # 두 개의 테이블 참조
```

```python
>>>     select(user_table.c.name, address_table.c.email_address).
...     join(address_table)
```

한편 우리가 FROM절에 추가 옵션을 주고 싶을 때는 Select.select_frim()메서드를 사용합니다.

```python
>>> print(
...     select(address_table.c.email_address).
...     select_from(user_table).join(address_table)
... )


SELECT address.email_address
FROM user_account JOIN address ON user_account.id = address.user_id
```

추가로 우리가 select 하고자 하는 컬럼들에 우리가 받아오고 싶은 컬럼이 없다면 <code>sqlalchemy.sql.expression.func</code>를 이용 할 수 있습니다.

```python
>>> from sqlalchemy import func
>>> print(select(func.count('*')).select_from(user_table))
...
...
SELECT count(:count_2) AS count_1
FROM user_account
```

<br>

### On절 세팅하기

이 전의 예제에서는 <code>Select</code>가 두 테이블을 조인하고 자동으로  ON절을 생성할 수 있음을 확인했습니다. 하지만 이는 <code>user_table</code>, <code>address_table</code>에 ForeignKeyConstraint 정의가 포함되어 있어서 가능한 것이었습니다.

만약에 Join의 대상인 왼쪽 테이블과 오른쪽 테이블이 이러한 제약 key가 없다거나 여러개의 key를 필요로 할 경우 ON 절을 직접 지정해야 합니다. 이러한 기능은 Select.join()과 Select 둘 다 제공하고 join_from()은 ON 절에 대한 추가 인수를 허용합니다.

```python
>>> print(
...     select(address_table.c.email_address).
...     select_from(user_table).
...     join(address_table, user_table.c.id == address_table.c.user_id)
... )

SELECT address.email_address
FROM user_account JOIN address ON user_account.id = address.user_id
```
<br>


### OUTER, FULL Join

<code>Select.join()</code>과 <code>Select.join_from()</code>메서드 둘 다 키워드 인자로 <code>Select.join.isouter</code>,
<code>Select.join.full </code>를 받고 이를 각 각
LEFT OUTER JOIN, FULL OUTER JOIN으로 렌더링 합니다.

```python
>>> print(
...     select(user_table).join(address_table, isouter=True)
... )

SELECT user_account.id, user_account.name, user_account.fullname
FROM user_account LEFT OUTER JOIN address ON user_account.id = address.user_id
```
<br>


## ORDER BY, GROUP BY, HAVING
  
<br>

### ORDER BY

<code>Select.order_by()</code>를 이용해 order_by()기능을 구현할 수 있고 오름차순, 내림차순은 
<code>ColumnElement.asc()</code><code>ColumnElement.desc()</code>를 
<code>order_by()</code> 인자값 앞에서 사용하면 됩니다.

```python
>>> print(select(user_table).order_by(user_table.c.name))

SELECT user_account.id, user_account.name, user_account.fullname
FROM user_account ORDER BY user_account.name

>>> print(select(User).order_by(User.fullname.desc()))

SELECT user_account.id, user_account.name, user_account.fullname
FROM user_account ORDER BY user_account.fullname DESC
```
<br>

### GROUP BY, Having을 이용한 집계함수 

SQL에서 집계 함수를 사용하면 여러 행에 걸쳐 있는 합쳐 단일 결과를 생성할 수 있습니다. 예를 들어 카운팅, 평균 계산은 물론 값 집합에서 최대값 또는 최소값을 찾는 작업을 할 수 있다. 

 SQLAlchemy는 func라고 하는 네임스페이스를 사용하여 SQL 함수를 개방형 방식으로 제공합니다. 이것은 특정 SQL 함수에 전달할 0개 이상의 인수가 지정된 경우 함수의 새 인스턴스를 만드는 특수 생성자 개체입니다. 예를 들어 user_account.id 열에 대해 SQL COUNT() 함수를 렌더링하려면 count() 이름을 호출합니다.


```python
>>> from sqlalchemy import func
>>> count_fn = func.count(user_table.c.id)
```

SQLAlchemy는 Select.group_by() 및 Select.having() 메서드를 사용하여 이 group_by와 having 기능을 제공합니다. 아래에서는 둘 이상의 주소를 가진 사용자에 대한 사용자 이름 필드 및 주소 수를 선택합니다.

```python
>>> with engine.connect() as conn:
...     result = conn.execute(
...         select(User.name, func.count(Address.id).label("count")).
...         join(Address).
...         group_by(User.name).
...         having(func.count(Address.id) > 1)
...     )
...     print(result.all())

[('sandy', 2)]
```

<br>


### 라벨을 통해 Ordering과 Grouping하기 

라벨을 통해 ordering, grouping하려면 스트링 텍스트의 이름을 <code>Select.order_by()</code> 또는 <code>Select.group_by()</code> 메서드에 전달하여 사용할 수 있습니다. 전달된 텍스트는 곧바로 렌더링되지 않습니다. 대신 컬럼절에 전잘 된 이름과 컨텍스트에 전달 된 이름이 일치하지 않으면 오류가 발생합니다.

```python
>>> from sqlalchemy import func, desc
>>> stmt = select(
...         Address.user_id,
...         func.count(Address.id).label('num_addresses')).\
...         group_by("user_id").order_by("user_id", desc("num_addresses"))
```
<br>


## 별칭 사용하기

<br>

### ORM 엔티티 별칭

 SQLAlchemy에서  as 구문을 통해 만들어진 이름들은  <code>FromClause</code> 객체를 사용하여 Core에 구성된 <code>FromClause.alias() method</code>
 를 이용하여 사용자에게 보여집니다.
  
SQLAlchemy에서는 별칭들은 <code>FromClause.Alias</code>생성자로 사용가능합니다.
<code>Alias</code>생성자는 Alias.c 컬렉션 내에 <code>Column</code>객체 네임스페이스도 있다는 점에서 <code>Table</code>생성자와 비슷합니다.

```python
>>> user_alias_1 = user_table.alias()
>>> user_alias_2 = user_table.alias()
```

<br>

## 서브쿼리와 CTE

이 섹션에서는 일반적으로 SELECT의 FROM 절에 있는 서브 쿼리에 대해 설명합니다. 서브쿼리와 유사한 방식으로 사용되지만 추가 기능이 포함된 CTE도 다룹니다.

SQLAlchemy는 <code>Subquery</code> 개체를 
<code>Select.subquery()</code>사용하여 서브 쿼리를 나타내고 <code>Select.cte()</code> 를 사용하여 CTE를 나타냅니다. 

```python
>>> subq = select(
...     func.count(address_table.c.id).label("count"),
...     address_table.c.user_id
... ).group_by(address_table.c.user_id).subquery()

>>> stmt = select(
...    user_table.c.name,
...    user_table.c.fullname,
...    subq.c.count
... ).join_from(user_table, subq) # ON절은 두 개의 테이블이 이미 foreigh key로 제약이 걸려있어 자동 바인딩된다.

```
<br>

### 계층 쿼리 
SQLAlchemy에서 CTE 구문을 사용하는 방법은 서브 쿼리 구문이 사용되는 방식과 거의 동일합니다. 대신 <code>Select.subquery()</code> 메서드의 호출을 Select.cte()를 사용하도록 변경하여 결과 객체를 FROM 요소로 사용할 수 있습니다. 

```python
>>> subq = select(
...     func.count(address_table.c.id).label("count"),
...     address_table.c.user_id
... ).group_by(address_table.c.user_id).cte()

>>> stmt = select(
...    user_table.c.name,
...    user_table.c.fullname,
...    subq.c.count
... ).join_from(user_table, subq)
```

<br>


### ORM 엔티티 서브쿼리/CTE
여기서는 <code>aliased()</code>가 <code>Subquery</code>, <code>CTE</code>서브 쿼리에 대해 동일한 작업을 수행하는 과정을 확인할 수 있습니다.

```python
>>> subq = select(Address).where(~Address.email_address.like('%@aol.com')).subquery()
>>> address_subq = aliased(Address, subq)
>>> stmt = select(User, address_subq).join_from(User, address_subq).order_by(User.id, address_subq.id)
>>> with Session(engine) as session:
...     for user, address in session.execute(stmt):
...         print(f"{user} {address}")
```
아래는 CTE생성자를 이용해 위와 같은  사용하는 예제입니다
```python
>>> cte = select(Address).where(~Address.email_address.like('%@aol.com')).cte()
>>> address_cte = aliased(Address, cte)
>>> stmt = select(User, address_cte).join_from(User, address_cte).order_by(User.id, address_cte.id)
>>> with Session(engine) as session:
...     for user, address in session.execute(stmt):
...         print(f"{user} {address}")

User(id=1, name='spongebob', fullname='Spongebob Squarepants') Address(id=1, email_address='spongebob@sqlalchemy.org')
User(id=2, name='sandy', fullname='Sandy Cheeks') Address(id=2, email_address='sandy@sqlalchemy.org')
User(id=2, name='sandy', fullname='Sandy Cheeks') Address(id=3, email_address='sandy@squirrelpower.org')
```
<br>


## 스칼라 쿼리, 상호연관 쿼리 

스칼라 서브 쿼리는 0 또는 1개의 ROW와 1개의 컬럼을 반환하는 서브 쿼리입니다. 
이 스칼라 서브 쿼리는 FROM 절에서 사용되지 않고 SELECT, COLUMNS절에서 사용된다는 점에서 일반 서브쿼리와 다릅니다.
상호연관 쿼리는 SELECT 절에 있는 테이블을 참조하는 스칼라 서브 쿼리입니다.

SQLAlchemy에서 스칼라 서브 쿼리는 <code>ColumnElement</code>계층의 일부인 <code>ScalarSelect</code> 구성을 사용하는 방면
반면 일반 서브 쿼리는<code>FromClause</code> 계층에 있는 <code>Subquery</code> 생성자를 사용합니다.

```python
>>> subq = select(func.count(address_table.c.id)).
...             where(user_table.c.id == address_table.c.user_id).
...             scalar_subquery()
```
 상호 연관 쿼리는 일반적으로 원하는 작업을 수행합니다. 그러나 상관 관계가 모호할 경우 SQLAlchemy는 더 명확한 설명이 필요하다는 것을 에러를 통해 알려줍니다.
```python
>>> stmt = select(
...     user_table.c.name,
...     address_table.c.email_address,
...     subq.label("address_count")
... ).\
... join_from(user_table, address_table).\
... order_by(user_table.c.id, address_table.c.id)
>>> print(stmt) #에러 발생 
```

스칼라 서브 쿼리는 자체적으로 문자열화될 때 FROM 절에서 user_account와 address를 모두 렌더링하지만 user_account 테이블을 처리하는 둘러싸는 select() 구문에 포함할 때 user_account 테이블은 자동으로 연결되므로 서브 쿼리의 FROM 절에서 렌더링되지 않습니다.

```python
>>> subq = select(func.count(address_table.c.id)).
...             where(user_table.c.id == address_table.c.user_id).
...             scalar_subquery().correlate(user_table)

>>> with engine.connect() as conn:
...     result = conn.execute(
...         select(
...             user_table.c.name,
...             address_table.c.email_address,
...             subq.label("address_count")
...         ).
...         join_from(user_table, address_table).
...         order_by(user_table.c.id, address_table.c.id)
...     )
...     print(result.all())
```

<br>


## UNION, UNION ALL 연산자들
SQL에서 SELECT 문은 UNION 또는 UNION ALL을 수행하여 결과물을 합칠 수 있으며 하나 이상의 쿼리에서 생성된 모든 행들을 집합을 생성합니다. <code>INTERSECT [ALL], EXCREST [ALL]</code>도 같은 역할을 수행할 수 있다. 

SQLAlchemy의 <code>Select</code> 생성자는 <code>union(), crossect(), except_all(),union_all(), crossect_all() ,except_all()</code>를 지원합니다.

이러한 함수로 생성되는 함수는 <code>CompoundSelect</code>이며, 이는 메서드가 더 적다는 점을 제외하고 <code>Select</code>와 비슷한 동일한 방식으로 사용됩니다.
```python
>>> from sqlalchemy import union_all
>>> stmt1 = select(user_table).where(user_table.c.name == 'sandy')
>>> stmt2 = select(user_table).where(user_table.c.name == 'spongebob')
>>> u = union_all(stmt1, stmt2)
>>> with engine.connect() as conn:
...     result = conn.execute(u)
...     print(result.all())
```
<code>CompoundSelect</code>를 하위 쿼리로 사용하려면 <code>SelectBase.subquery()</code> 메서드를 사용하여 FromClause.c 컬렉션을 생성하는 Subquery() 메서드를 제공합니다.

```python
>>> u_subq = u.subquery()
>>> stmt = (
...     select(u_subq.c.name, address_table.c.email_address).
...     join_from(address_table, u_subq).
...     order_by(u_subq.c.name, address_table.c.email_address)
... )
>>> with engine.connect() as conn:
...     result = conn.execute(stmt)
...     print(result.all())
```

<br>

## EXISTS 서브쿼리들

SQL EXISTS 키워드는  SELECT 문이 행을 반환하는지 여부에 따라 True 또는 false를 반환합니다.
 EXISTS 키워드 스칼라 서브 쿼리와 함께 사용되는 연산자입니다.

SQLAlchemy는 ScalarSelect 객체의 종류 중 하나로 Exists 객체를 갖고 있는데 이는 EXISTS 서브쿼리를 생성하고 SelectBase.exists()라는 메서드를 통해 Exists객첼르 생성할 수 있습니다.

```python
>>> subq = (
...     select(func.count(address_table.c.id)).
...     where(user_table.c.id == address_table.c.user_id).
...     group_by(address_table.c.user_id).
...     having(func.count(address_table.c.id) > 1)
... ).exists()
>>> with engine.connect() as conn:
...     result = conn.execute(
...         select(user_table.c.name).where(subq)
...     )
...     print(result.all())

[('sandy',)]
```

한편 EXISTS 구문은 부정으로 사용되지 않는 경우가 더 많습니다.
```python
# 이메일 주소가 없는 유저네임을 선택하는 쿼리문입니다.
# "~" 연산이 들어간 부분을 확인해보세요
>>> subq = (
...     select(address_table.c.id).
...     where(user_table.c.id == address_table.c.user_id)
... ).exists()
>>> with engine.connect() as conn:
...     result = conn.execute(
...         select(user_table.c.name).where(~subq) 
...     )
...     print(result.all())
```

<br>


## SQL 함수 다뤄보기
SQL 함수 작업
이 섹션 앞부분의 GROUP BY / HAVING을 사용한 집계 함수에서 처음 소개된 <code>func</code> 객체는
새로운 <code>Function</code> 객체를 생성하기 위한 팩토리 역할을 합니다.  
여기서 <code>Function</code> 객체는 <code>select()</code>와 같은 구문을 사용 할 때   
이름,괄호(항상 그렇지는 않지만) 종종 인자값등 으로 구성된 SQL 함수를 생성합니다.  
일반적인 SQL 함수는 다음과 같습니다.


- <code>count()</code> : 집계 함수로 몇개의 행이 반환되었지 세서 그 수를 반환해줍니다.
  ```python
  >>> print(select(func.count()).select_from(user_table))
  
  SELECT count(*) AS count_1FROM user_account
  ```
- <code>lower()</code> : 문자열 함수로 스트링 문자열을 소문자로 바꿔줍니다.
  ```python
  >>> print(select(func.lower("A String With Much UPPERCASE")))
  
  SELECT lower(:lower_2) AS lower_1
  ```
- <code>now()</code> : 현재 시간과 날짜를 반환해주는 함수입니다. 
  이 함수는 굉장히 흔하게 사용되는 함수이기에 SQLAlchemy는 서로 다른 백엔드에서 손쉽게 렌더링 할 수 있도록 도와줍니다. 
  ```` python
  #SQLite에서 CURRENT_TIMESTAMP함수로 쓰일 경우 
  >>> stmt = select(func.now())
  >>> with engine.connect() as conn:
  ...     result = conn.execute(stmt)
  ...     print(result.all())
  ````

<br> 

### 리턴 타입이 있는 함수Functions Have Return Types

SQL에서도 데이터 타입이 있는데 SQLAlchemy에서는 "SQL 리턴 타입"이라고 말합니다.

아래와 <code>Function.type</code>속성을 이용해 SQL 함수의 SQL 리턴타입을 확인 할 수 있습니다.
```python
>>> func.now().type
DateTime()
```

이러한 SQL 리턴 유형은 길이가 긴 쿼리에서 함수 표현식을 사용할 때 중요합니다.
예를 들면 수학 연산자는 표현식의 데이터 유형이 <code>Integer</code> 또는 <code>Numeric</code> 
일때 더 잘 작동되고 JSON 접근자를 처리하려면 <code>JSON</code> 타입을 사용해야합니다.

한편 특정 클래스의 함수는 특정 열을 참조해야 하는 경우 컬럼 값 대신 전체 행을 반환하는데 이러한 함수를
<COde>table valued functions. </code>

함수에 특정 타입을 적용하려면 <code>Function.type_</code> 파라미터를 사용하여 전달해야합니다. 
타입 인수는 <code>TypeEngine</code>의 클래스 또는 인스턴스일 수 있습니다.
아래 예제에서 <code>JSON</code> 클래스를 전달하여 PostgreSQL <code>json_object()</code>
함수를 생성합니다. 이때 SQL 리턴 타입은 JSON 유형이 됩니다.

```python
>>> from sqlalchemy import JSON
>>> function_expr = func.json_object('{a, 1, b, "def", c, 3.5}', type_=JSON)
>>> stmt = select(function_expr["def"])
>>> print(stmt)

SELECT json_object(:json_object_1)[:json_object_2] AS anon_1
```


<br> 

### Built-in Functions Have Pre-Configured Return Types
> 원문의 Built-in Functions Have Pre-Configured Return Types 부분은 제가 이해하지 못했습니다. 
> 이에 대해 이해하신 분 있으시다면 이 부분에 기여 부탁드립니다. 감사합니다.


<br> 

### 윈도우 함수

SQLAlchemy에서는, <code>func</code> 네임스페이스에 의해 생성된 모든 SQL 함수에는
윈도우 함수 또는 "OVER 구문을 부여하는  <code>FunctionElement.over()</code> 메서드가 포함되어 있습니다.


윈도우 함수와 함께 사용되는 일반적인 함수는 단순히 행을 계산하는 row_number() 함수입니다.

```python
# FunctionElement.over.partition_by파라미터는를 사용하여 
# PARTITION BY 절이 OVER 절에 렌더링되도록 했습니다.

>>> stmt = select(
...     func.row_number().over(partition_by=user_table.c.name),
...     user_table.c.name,
...     address_table.c.email_address
... ).select_from(user_table).join(address_table)
>>> with engine.connect() as conn:  
...     result = conn.execute(stmt)
...     print(result.all())
# 이 행을 사용자 이름에 대해 분할하여 각 각의 사용자이메일 주소에 번호를 매길 수 있습니다.
[(1, 'sandy', 'sandy@sqlalchemy.org'), 
 (2, 'sandy', 'sandy@squirrelpower.org'), 
 (1, 'spongebob', 'spongebob@sqlalchemy.org')]
```
<code>FunctionElement.over.order_by</code>를 사용하여 ORDER BY 절을 사용할 수도 있습니다.
```python
>>> stmt = select(
...     func.count().over(order_by=user_table.c.name),
...     user_table.c.name,
...     address_table.c.email_address).select_from(user_table).join(address_table)
>>> with engine.connect() as conn:  
...     result = conn.execute(stmt)
...     print(result.all())

[(2, 'sandy', 'sandy@sqlalchemy.org'), 
 (2, 'sandy', 'sandy@squirrelpower.org'), 
 (3, 'spongebob', 'spongebob@sqlalchemy.org')]
```
<br> 

### WITHIN GROUP, FILTER등 특수한 지정자

"WITHIN GORUP"이라는 SQL 구문은 순서 집합 또는 가상 집합 그리고 집계함수와 함께 쓰입니다.
일반적인 순서 집합 함수는 <code>percentile_cont()(</code> 그리고 <code>rank()</code>를 포함하고 있습니다.
SQLAlchemy에서는 <code>rank, dense_rank, percentile_count, percentile_disc</code>가 구현되어 있고
각 각은 <code>FunctionElement.within_group()</code>메서드를 갖고 있습니다.

```python
>>> print(
...     func.unnest(
...         func.percentile_disc([0.25,0.5,0.75,1]).within_group(user_table.c.name)
...     )
... )

unnest(percentile_disc(:percentile_disc_1) WITHIN GROUP (ORDER BY user_account.name))
```
어떤 백엔드에서는 "FILTER"를 지원하는데 이는 <code> FunctionElement.filter()</code>메서드로 
사용이 가능합니다. 
```python
>>> stmt = select(
...     func.count(address_table.c.email_address).filter(user_table.c.name == 'sandy'),
...     func.count(address_table.c.email_address).filter(user_table.c.name == 'spongebob')
... ).select_from(user_table).join(address_table)
>>> with engine.connect() as conn:  
...     result = conn.execute(stmt)
...     print(result.all())

[...] ('sandy', 'spongebob')
[(2, 1)]
```

<br> 

### Table-Valued Functions
> 원문의 Table-Valued Functions 부분은 제가 이해하지 못했습니다. 
> 이에 대해 이해하신 분 있으시다면 이 부분에 기여 부탁드립니다. 감사합니다.



### 컬럼-값 함수
Oracle과 PostgresSQL에서 지원하는 특별 문법 중 하나로 FROM절을 참조하는 함수가 있습니다.
이 함수는 FROM절을 참조한 다음 SELECT 절에 있는 하나의 컬럼으로 자기 자신(함수)를 전달 할 수 있습니다.
PostgreSQL에서는 json_array_elements(), json_object_keys(), json_each_text(), json_each()등의 함수로 쓸 수 있습니다.
한편 SQLAlchemy는 이것을 컬럼 값이라고 하며 <code>FunctionElement.column_valued()</code>지정자를 적용하여 사용할 수 있습니다.
```python
>>> from sqlalchemy import select, func
>>> stmt = select(func.json_array_elements('["one", "two"]').column_valued("x"))
>>> print(stmt)

SELECT x
FROM json_array_elements(:json_array_elements_1) AS x
```

컬럼값의 형태는 오라클 방언에서 지원되는데 이는 커스텀 SQL 함수에서 사용할 수 있습니다.

```python
>>> from sqlalchemy.dialects import oracle
>>> stmt = select(func.scalar_strings(5).column_valued("s"))
>>> print(stmt.compile(dialect=oracle.dialect()))

SELECT COLUMN_VALUE s
FROM TABLE (scalar_strings(:scalar_strings_1)) s
```
